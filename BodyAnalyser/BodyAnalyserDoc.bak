// BodyAnalyserDoc.cpp : implementation of the CBodyAnalyserDoc class
//

#include "stdafx.h"
#include "BodyAnalyser.h"

#include "BodyAnalyserDoc.h"
#include "BodyAnalyserView.h"
#include "DialogCameraImager.h"
#include "CameraImageFrame.h"
#include "ConfirmDialog.h"
#include "NoCurvMapDialog.h"
#include "CurvMapConfirmDialog.h"
#include "CannyParamsDialog.h"
#include "DlgCurvatureProgress.h"

#include <fstream.h>
#include <process.h>
#include <string.h>

#include <Inventor/nodes/SoCoordinate3.h>
#include <Inventor/nodes/SoCone.h>
#include <Inventor/nodes/SoMaterial.h>
#include <Inventor/nodes/SoSeparator.h>
#include <Inventor/nodes/SoPointSet.h>
#include <Inventor/nodes/SoLineSet.h>
#include <Inventor/nodes/SoIndexedFaceSet.h>
#include <Inventor/nodes/SoNormal.h>
#include <Inventor/nodes/SoBaseColor.h>
#include <Inventor/nodes/SoTranslation.h>
#include <Inventor/nodes/SoSphere.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include <MathTools.h>

// for the curvature estimation

#define UNDEFINED	0
#define BOTH1		1
#define BOTH2		2
#define FLAT		3
#define TOUGH		4
#define BOTH		5



/////////////////////////////////////////////////////////////////////////////
// CBodyAnalyserDoc

IMPLEMENT_DYNCREATE(CBodyAnalyserDoc, CDocument)

BEGIN_MESSAGE_MAP(CBodyAnalyserDoc, CDocument)
	//{{AFX_MSG_MAP(CBodyAnalyserDoc)
	ON_COMMAND(ID_FILE_IMPORT, OnFileImport)
	ON_UPDATE_COMMAND_UI(ID_FILE_IMPORT, OnUpdateFileImport)
	ON_UPDATE_COMMAND_UI(IDM_VIEWPOINTS, OnUpdateViewpoints)
	ON_COMMAND(ID_FILE_SAVE_AS, OnFileSaveAs)
	ON_COMMAND(ID_FILE_RELOAD, OnFileReload)
	ON_UPDATE_COMMAND_UI(ID_FILE_RELOAD, OnUpdateFileReload)
	ON_COMMAND(ID_VIEW_POINTCLOUD, OnViewPointcloud)
	ON_UPDATE_COMMAND_UI(ID_VIEW_POINTCLOUD, OnUpdateViewPointcloud)
	ON_COMMAND(ID_VIEW_REFERENCEFRAME, OnViewReferenceframe)
	ON_UPDATE_COMMAND_UI(ID_VIEW_REFERENCEFRAME, OnUpdateViewReferenceframe)
	ON_COMMAND(ID_VIEW_COORDINATEORIGIN, OnViewCoordinateorigin)
	ON_UPDATE_COMMAND_UI(ID_VIEW_COORDINATEORIGIN, OnUpdateViewCoordinateorigin)
	ON_COMMAND(ID_VIEW_CONNECTEDMESH_CAMERA0, OnViewConnectedmeshCamera0)
	ON_UPDATE_COMMAND_UI(ID_VIEW_CONNECTEDMESH_CAMERA0, OnUpdateViewConnectedmeshCamera0)
	ON_COMMAND(ID_VIEW_CONNECTEDMESH_NONE, OnViewConnectedmeshNone)
	ON_UPDATE_COMMAND_UI(ID_VIEW_CONNECTEDMESH_NONE, OnUpdateViewConnectedmeshNone)
	ON_COMMAND(ID_VIEW_CONNECTEDMESH_ALL, OnViewConnectedmeshAll)
	ON_UPDATE_COMMAND_UI(ID_VIEW_CONNECTEDMESH_ALL, OnUpdateViewConnectedmeshAll)
	ON_COMMAND(ID_VIEW_CONNECTEDMESH_CAMERA1, OnViewConnectedmeshCamera1)
	ON_UPDATE_COMMAND_UI(ID_VIEW_CONNECTEDMESH_CAMERA1, OnUpdateViewConnectedmeshCamera1)
	ON_COMMAND(ID_VIEW_CONNECTEDMESH_CAMERA2, OnViewConnectedmeshCamera2)
	ON_UPDATE_COMMAND_UI(ID_VIEW_CONNECTEDMESH_CAMERA2, OnUpdateViewConnectedmeshCamera2)
	ON_COMMAND(ID_VIEW_CONNECTEDMESH_CAMERA3, OnViewConnectedmeshCamera3)
	ON_UPDATE_COMMAND_UI(ID_VIEW_CONNECTEDMESH_CAMERA3, OnUpdateViewConnectedmeshCamera3)
	ON_COMMAND(ID_VIEW_CONNECTEDMESH_CAMERA4, OnViewConnectedmeshCamera4)
	ON_UPDATE_COMMAND_UI(ID_VIEW_CONNECTEDMESH_CAMERA4, OnUpdateViewConnectedmeshCamera4)
	ON_COMMAND(ID_VIEW_CONNECTEDMESH_CAMERA5, OnViewConnectedmeshCamera5)
	ON_UPDATE_COMMAND_UI(ID_VIEW_CONNECTEDMESH_CAMERA5, OnUpdateViewConnectedmeshCamera5)
	ON_COMMAND(ID_VIEW_CONNECTEDMESH_CAMERA6, OnViewConnectedmeshCamera6)
	ON_UPDATE_COMMAND_UI(ID_VIEW_CONNECTEDMESH_CAMERA6, OnUpdateViewConnectedmeshCamera6)
	ON_COMMAND(ID_VIEW_CONNECTEDMESH_CAMERA7, OnViewConnectedmeshCamera7)
	ON_UPDATE_COMMAND_UI(ID_VIEW_CONNECTEDMESH_CAMERA7, OnUpdateViewConnectedmeshCamera7)
	ON_COMMAND(ID_TOOLS_CAMERAIMAGER, OnToolsCameraImager)
	ON_COMMAND(ID_VIEW_OUTLIERCLOUD, OnViewOutliercloud)
	ON_UPDATE_COMMAND_UI(ID_VIEW_OUTLIERCLOUD, OnUpdateViewOutliercloud)
	ON_COMMAND(ID_VIEW_CONNECTEDMESH_INTENSITIES, OnUseIntensities)
	ON_UPDATE_COMMAND_UI(ID_VIEW_CONNECTEDMESH_INTENSITIES, OnUpdateUseIntensities)
	ON_COMMAND(ID_TOOLS_SURFACESMOOTHING, OnToolsSurfacesmoothing)
	//ON_COMMAND(ID_TOOLS_CURVATUREMAP, OnToolsCurvaturemap)
	ON_COMMAND(ID_VIEW_CONNECTEDMESH_CURVATURECOLOURMAP, OnViewConnectedmeshCurvaturecolourmap)
	ON_UPDATE_COMMAND_UI(ID_VIEW_CONNECTEDMESH_CURVATURECOLOURMAP, OnUpdateViewConnectedmeshCurvaturecolourmap)
	ON_COMMAND(ID_TOOLS_TEXTUREEDGEDETECTOR, OnToolsTextureedgedetector)
	ON_UPDATE_COMMAND_UI(ID_TOOLS_TEXTUREEDGEDETECTOR, OnUpdateToolsTextureedgedetector)
	ON_UPDATE_COMMAND_UI(ID_VIEW_CONNECTEDMESH_TEXTUREEDGELS, OnUpdateViewConnectedmeshTextureedgels)
	ON_COMMAND(ID_VIEW_CONNECTEDMESH_TEXTUREEDGELS, OnViewConnectedmeshTextureedgels)
	ON_COMMAND(ID_TOOLS_HISTOGRAMEQUALISATION, OnToolsHistogramequalisation)
	//ON_UPDATE_COMMAND_UI(ID_TOOLS_CURVATUREMAP, OnUpdateToolsCurvaturemap)
	ON_COMMAND(ID_TOOLS_CURVATUREMAP_EXPORTCOVARIANCES, OnToolsCurvaturemapExportcovariances)
	ON_COMMAND(ID_TOOLS_CURVATUREMAP_RETRIEVEEIGENSOLUTIONSANDCOMPLETE, OnToolsCurvaturemapRetrieveeigensolutions)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBodyAnalyserDoc construction/destruction

CBodyAnalyserDoc::CBodyAnalyserDoc()
{
	// TODO: add one-time construction code here

// BEGIN_IVWGEN
	m_bContainsCamera = FALSE;
	m_eOpenType = IVFDOC_OPEN_NORMAL;
// END_IVWGEN

	int s,i;

	m_showPointCloud	= FALSE;
	m_showOutlierCloud  = FALSE;
	m_showCoordOrigin	= TRUE;
	m_showRefFrame		= TRUE;
	m_showTextureEdgels	= FALSE;

	m_bHasData = FALSE;
	m_data_source = NONE;

	m_x_correction = X_CORRECTION;
	m_y_correction = Y_CORRECTION;
	m_z_correction = Z_CORRECTION;

	// copy scanner params from the app
	for (i=0; i<N_CAMERAS; i++)
	{
		m_scanner_params.m_hdx[i] = (theApp.Params()).m_hdx[i];
		m_scanner_params.m_hdy[i] = (theApp.Params()).m_hdy[i];
		m_scanner_params.m_hda[i] = (theApp.Params()).m_hda[i];
		//m_show_head[i] = TRUE;
	}
	m_scanner_params.m_params_file = (theApp.Params()).m_params_file;


	m_input_file = "";

	for (s=0; s<N_SLICES; s++)
	{
		m_xyz_array[s] = new SbVec3f[N_CAMERAS*N_LEDS];
		m_norm_array[s] = new SbVec3f[N_CAMERAS*N_LEDS];
		m_b_array[s] = new unsigned char[N_CAMERAS*N_LEDS];
		m_flag_array[s] = new unsigned char[N_CAMERAS*N_LEDS];
		m_indices[s] = new long[N_CAMERAS*N_LEDS];
		for (i=0; i<(N_CAMERAS*N_LEDS); i++)
		{
			m_b_array[s][i] = 0;
			m_flag_array[s][i] = ACCEPTED;
			m_indices[s][i] = SO_END_FACE_INDEX;
		}
	}

	m_surface_smoothed = FALSE;
	m_curv_map_calculated = FALSE;
	m_texture_edges_detected = FALSE;
	//for (i=0; i<N_CAMERAS; i++)	{m_Current_Material[i] = new SoMaterial;}

	c_gmask = 7;
	c_lhthr = 20;
	c_uhthr = 100;

}

CBodyAnalyserDoc::~CBodyAnalyserDoc()
{
}

BOOL CBodyAnalyserDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

 
// BEGIN_IVWGEN
	IvfOnNewDocument();
// END_IVWGEN
 
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CBodyAnalyserDoc serialization

void CBodyAnalyserDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
// BEGIN_IVWGEN
            IvfOnSaveDocument(ar.GetFile()->m_hFile) ;
// END_IVWGEN
 
	}
	else
	{
// BEGIN_IVWGEN
		IvfOnOpenDocument(ar.GetFile()->m_hFile) ;
// END_IVWGEN
	}
}

/////////////////////////////////////////////////////////////////////////////
// CBodyAnalyserDoc diagnostics

#ifdef _DEBUG
void CBodyAnalyserDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CBodyAnalyserDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CBodyAnalyserDoc commands




//  OnFileImport --
//  yet another special file open scenario.  still want to route
//  through OpenDocument to handle menus, urls, etc., but don't
//  want to actually update the document per se.  This just gets
//  added to the current doc.
//
void CBodyAnalyserDoc::OnFileImport()
{
m_eOpenType = IVFDOC_OPEN_IMPORT;
theApp.OnFileOpen();
}


void CBodyAnalyserDoc::OnUpdateFileImport(CCmdUI *pCmdUI)
{
pCmdUI->Enable(m_pSceneRoot != NULL);
}


BOOL CBodyAnalyserDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
return(IvfOnOpenDocumentMessage(lpszPathName));
}

void CBodyAnalyserDoc::OnUpdateViewpoints(CCmdUI* pCmdUI) 
{
IvfOnUpdateViewpoints(pCmdUI);
}


static char spv_save_suffix[] = ".iv";
static char spv_save_filter[] =
   "Inventor Files (*.iv)\0*.iv\0Vrml Files (*.wrl)\0*.wrl\0BMP Files (*.bmp)\0*.bmp\0";

void CBodyAnalyserDoc::OnFileSaveAs() 
{
CFileDialog save_dlg(FALSE);
                        //  create the dialog

	save_dlg.m_ofn.lpstrFilter = spv_save_filter ;
	save_dlg.m_ofn.nFilterIndex = 1L;
	save_dlg.m_ofn.lpstrCustomFilter = NULL;
	save_dlg.m_ofn.lpstrDefExt = spv_save_suffix+1;
	save_dlg.m_ofn.nMaxCustFilter = 0;
        save_dlg.m_ofn.lpstrFile[0] = '\0';

	save_dlg.m_ofn.Flags |= (OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT) ;


if (save_dlg.DoModal() != IDCANCEL)
   {
   BOOL stat = FALSE;

   // Note: Saving may change the file type, e.g. from Inventor to VRML 
   switch (save_dlg.m_ofn.nFilterIndex)
      {
      case 1: 	// .iv file
         IvfSetFileType(IVF_FILETYPE_IV);
         stat = OnSaveDocument(save_dlg.m_ofn.lpstrFile);
         break;
			// Set filetype to Inventor in case it was VRML.

      case 2:	// .wrl file
         /*
		  if (IvfGetFileType() == IVF_FILETYPE_IV)
            IvfSetFileType(IVF_FILETYPE_VRML);
         stat = OnSaveDocument(save_dlg.m_ofn.lpstrFile);
		 */
		  stat = SaveAsVRML2(save_dlg.m_ofn.lpstrFile);
         break;
			//  VRML requires new header - need to set the filetype.
                        //  Don't change if file was read in as VRML or VRML2.

      case 3:	// .bmp file
         {
         CBodyAnalyserView *t_view =
	    (CBodyAnalyserView *)CIvfApp::IvfGetAfxView();
         stat = t_view->SaveAsBitmap(save_dlg.m_ofn.lpstrFile);
         }
         break;
			//  .bmp is totally different - let view handle.
      }
   }
}

BOOL CBodyAnalyserDoc::SaveAsVRML2(LPCTSTR lpszPathName)
{
	ofstream vrml_file;
	vrml_file.open(lpszPathName);

	int cam;
	int start, finish;
	int index, slice;
	float x,y,z;
	long int a, b, c;

	vrml_file << "#VRML V2.0 utf8\n\n";

	vrml_file << "Viewpoint {\n";
    vrml_file << "orientation    0 0 1 0 \n";
    vrml_file << "position       0 10000 50000\n";   
    vrml_file << "}\n\n";

	for(cam = 0; cam < N_CAMERAS; cam++)
	{

		start = camera_start[cam]+1;
		finish = camera_end[cam]-1;

		vrml_file << "Shape {\n";

		vrml_file << "geometry IndexedFaceSet {\n";

		vrml_file << "coord Coordinate {\n";
		vrml_file << "point [\n";
	
		for(slice = 0; slice<N_SLICES; slice++)
		{
			for(index = start; index<=finish; index++)
			{
				if (m_indices[slice][index] != SO_END_FACE_INDEX)
				{
					m_xyz_array[slice][index].getValue(x,y,z);
					vrml_file << "" << x << " " << y << " " << z << "\n";
				}
			}
		}

		vrml_file << "]\n";
		vrml_file << "}\n";	// end of coord

		vrml_file << "normal Normal {\n";
		vrml_file << "vector [\n";
	
		for(slice = 0; slice<N_SLICES; slice++)
		{
			for(index = start; index<=finish; index++)
			{
				if (m_indices[slice][index] != SO_END_FACE_INDEX)
				{
					m_norm_array[slice][index].getValue(x,y,z);
					vrml_file << "" << x << " " << y << " " << z << "\n";
				}
			}
		}

		vrml_file << "]\n";
		vrml_file << "}\n";	// end of normal
	
		vrml_file << "color Color {\n";
		vrml_file << "color [\n";

		for(slice = 0; slice<N_SLICES; slice++)
		{
			for(index = start; index<=finish; index++)
			{
				if (m_indices[slice][index] != SO_END_FACE_INDEX)
				{
					x = m_b_array[slice][index] / 256.0;
					vrml_file << "" << x << " " << x << " " << x << "\n";
				}
			}
		}

		vrml_file << "]\n";
		vrml_file << "}\n";	// end of colo(u)r

		vrml_file << "coordIndex [\n";
	
		for(index = start; index<finish; index++)
		{
			for(slice = 0; slice<N_SLICES-1; slice++)
			{
				if (m_indices[slice][index] != SO_END_FACE_INDEX)
				{
					//downwards
					if(
						(m_indices[slice][index] != SO_END_FACE_INDEX) &&
						(m_indices[slice+1][index] != SO_END_FACE_INDEX) &&
						(m_indices[slice+1][index+1] != SO_END_FACE_INDEX)
						)
					{
						a = m_indices[slice][index];
						b = m_indices[slice+1][index];
						c = m_indices[slice+1][index+1];
						vrml_file << "" << a << " " << b << " " << c << " " << SO_END_FACE_INDEX << "\n";
					}

					//to the right
					if(
						(m_indices[slice][index] != SO_END_FACE_INDEX) &&
						(m_indices[slice][index+1] != SO_END_FACE_INDEX) &&
						(m_indices[slice+1][index+1] != SO_END_FACE_INDEX)
						)
					{
						a = m_indices[slice][index+1];
						b = m_indices[slice][index];
						c = m_indices[slice+1][index+1];
						vrml_file << "" << a << " " << b << " " << c << " " << SO_END_FACE_INDEX << "\n";
					}
				}
			}
		}
		
		
		vrml_file << "]\n";	// end of coordindex

		vrml_file << "}\n"; // end of indexedfaceset

		vrml_file << "}\n";	// end of shape
	
	}

	vrml_file.close();
	return 1;
}


BOOL CBodyAnalyserDoc::OnSaveDocument(LPCTSTR lpszPathName) 
{
BOOL stat;
CBodyAnalyserView *pView =
   (CBodyAnalyserView *)CIvfApp::IvfGetAfxView();

//  pView->SendMessage(WM_COMMAND, ID_VIEW_VIEWINGMODE, 0);
		//  don't need this any more ??


stat = CDocument::OnSaveDocument(lpszPathName);

return(stat);
}

void CBodyAnalyserDoc::OnFileReload() 
{
CIvfApp *pApp = CIvfApp::IvfGetApp();

IvfDeleteContents();
OnOpenDocument(GetPathName());
if (pApp->IvfIsMdi()) IvfSceneGraphChanged();
			//  an mdi app needs to treat the single
			//  frame as an SDI to reload.
}

void CBodyAnalyserDoc::OnUpdateFileReload(CCmdUI* pCmdUI) 
{
pCmdUI->Enable(m_pSceneRoot != NULL);
}



void CBodyAnalyserDoc::IvfSetupUrlFetchCallback(void)
{
CIvfDocument::IvfSetupUrlFetchCallback();
}

short CBodyAnalyserDoc::OpenSCFile(const CString& input_file)
{
	ifstream ppm_file;
	int cams, slices, indices, tones, chans;

	int slice, camera, index;

	float curr_x, curr_y, curr_z;
	int curr_g;
	SbVec3f curr_v;

	ppm_file.open(input_file, ios::nocreate|ios::in);
	if (!ppm_file.good())
	{
		return FALSE;
	}
	else
	{
		ppm_file >> cams;
		ppm_file >> indices;
		ppm_file >> slices;
		ppm_file >> tones;
		ppm_file >> chans;

		if (1==1 /*(indices==N_LEDS) && (slices==N_SLICES) && (tones==N_GSCALES) */)
		{
			N_CAMERAS	= cams;
			N_LEDS		= indices;
			N_SLICES	= slices;
			N_GSCALES	= tones;
			N_CHANNELS	= chans;

			for(camera = 0; camera < N_CAMERAS; camera++)
			{
				for(slice = 0; slice < N_SLICES; slice++)
				{
					for(index = 0; index < N_LEDS; index++)
					{
						ppm_file >> curr_x;
						ppm_file >> curr_y;
						ppm_file >> curr_z;
						ppm_file >> curr_g;

						if (curr_g!=(-1))
						{
							m_flag_array[slice][index+(camera*N_LEDS)] = ACCEPTED;
						}
						else
						{
							m_flag_array[slice][index+(camera*N_LEDS)] = REJECTED;
						}

						curr_v.setValue(curr_x,curr_y,curr_z);
						m_xyz_array[slice][index+(camera*N_LEDS)] = curr_v;
						m_b_array[slice][index+(camera*N_LEDS)] = curr_g;


					}
				}
			}

			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}

	ppm_file.close();


}

short CBodyAnalyserDoc::OpenFile(const CString& input_file)
{
	int head, slice, index;
	int num_in;
	int buf_num, rel_index;
	short* dist_buf;
	unsigned char* br_buf;

	ifstream bls_file;

	bls_file.open(input_file, ios::nocreate|ios::in);
	if (!bls_file.good())
		return FALSE;

	const int sz_header = 16;
	const int sz_dword = 4;
	const int sz_float = 4;

	DWORD x, y;
	float a;
	char header[sz_header];
	
	m_bHasData = TRUE;

	bls_file >> binary;
	bls_file.read(header, 16);

	m_data_source = BLS_ASCII;
	if (!strcmp(header, "BLS_V_10_150997"))
		m_data_source = BLS_V_10_150997;
	if (!strcmp(header, "BLS_V009_300998"))
		m_data_source = BLS_V009_300998;

	switch(m_data_source)
	{
		case(BLS_V009_300998):
			// binary format: app opens file and gets data as if 
			// downloading directly from hardware; doc then gets
			// the data from the app
			for (head=0; head<8; head++)
			{
				bls_file.read((char*)(&x), sz_dword);
				m_scanner_params.m_hdx[head] = x;
				bls_file.read((char*)(&y), sz_dword);
				m_scanner_params.m_hdy[head] = y;
				bls_file.read((char*)(&a), sz_float);
				m_scanner_params.m_hda[head] = a;
			}
			m_scanner_params.m_params_file = input_file;
			// get the rest of the data
			theApp.OpenFromFile(bls_file);
			GetDownload();
			break;

		case(BLS_V_10_150997):
			// binary format: app opens file and gets data as if 
			// downloading directly from hardware; doc then gets
			// the data from the app
			theApp.OpenFromFile(bls_file);
			GetDownload();
			break;

		case(BLS_ASCII):
			// close file and reopen it as text
			bls_file.close();
			bls_file.open(input_file);
			// old ASCII format
			// convert the string to integer (num_in)

			// need also to store data in the app's raw data buffers in case
			// we want to save it later in a different format

			// distance values
			for (slice=0; slice<N_SLICES; slice++)
			{
				buf_num = slice/100; // int division
				switch(buf_num)
				{
				case 0:
					dist_buf = theApp.m_dist1;
					break;
				case 1:
					dist_buf = theApp.m_dist2;
					break;
				case 2:
					dist_buf = theApp.m_dist3;
					break;
				case 3:
					dist_buf = theApp.m_dist4;
					break;
				}

				for (index=0; index<(N_LEDS*N_CAMERAS); index++)
				{
					bls_file >> num_in;
					m_xyz_array[slice][index] = Cartesian(slice,index,num_in);
					rel_index = (slice*(N_LEDS*N_CAMERAS)+index)%25600;
					dist_buf[rel_index] = num_in; // store raw value
				}
				// if ASCII, error in input - data was stored as 4x25601 values
				if (slice%100==99)
					bls_file >> num_in;	
			}			
			// brightness values
			for (slice=0; slice<N_SLICES; slice++)
			{
				buf_num = slice/100; // int division
				switch(buf_num)
				{
				case 0:
					br_buf = theApp.m_brbuf1;
					break;
				case 1:
					br_buf = theApp.m_brbuf2;
					break;
				case 2:
					br_buf = theApp.m_brbuf3;
					break;
				case 3:
					br_buf = theApp.m_brbuf4;
					break;
				}

				for (index=0; index<(N_LEDS*N_CAMERAS); index++)
				{
					bls_file >> num_in;
					m_b_array[slice][index] = num_in;
					rel_index = (slice*(N_LEDS*N_CAMERAS)+index)%25600;
					br_buf[rel_index] = num_in;	// store raw value
				}
				// if version 0.x, error in input - data was stored as 4x25601 values
				if (slice%100==99)
					bls_file >> num_in;	
			}
			// initialise flag array
			// at start we don't know to which part of the body points belong
			// so designate them as WHOLE body until we know
			for (slice=0; slice<N_SLICES; slice++)
			{
				for (index=0; index<(N_LEDS*N_CAMERAS); index++)
					m_flag_array[slice][index] = ACCEPTED;	
			}
			break;
	}	
	
	bls_file.close();
	m_input_file = input_file;	
	return TRUE;
}

BOOL CBodyAnalyserDoc::GetDownload(void)
{
	int slice, index;
	m_bHasData = TRUE;
	short distance, brightness;

	for (slice=0; slice<N_SLICES; slice++)
	{
		for (index=0; index<(N_LEDS*N_CAMERAS); index++)
		{			
			distance = theApp.GetDistance(slice,index);
			m_xyz_array[slice][index] = Cartesian(slice,index,distance);		
			brightness = theApp.GetBrightness(slice,index);
			m_b_array[slice][index] = brightness;	
		}
	}

	// initialise flag array
	// at start we don't know to which part of the body points belong
	// so designate them as WHOLE body until we know
	for (slice=0; slice<N_SLICES; slice++)
	{
		for (index=0; index<(N_LEDS*N_CAMERAS); index++)
		{
			m_flag_array[slice][index] = ACCEPTED;	
		}
	}

	//char cwd[256];
	//_getcwd(cwd, 256);
	//m_input_file = cwd;
	//m_input_file += "\\tmp.bls";
	m_data_source = HARDWARE;
	return TRUE;

}

SbVec3f& CBodyAnalyserDoc::Cartesian(int slice, int index, int distance)
{
	assert(slice >= 0  &&  slice < N_SLICES  &&  index >=0  && index < (N_LEDS*N_CAMERAS));

	float dm, xn, yn, zn;
	float angle, d_angle;
    
    // calculate the x and y values according to the distance data,
    // using the angle obtained from the head number and LED number
	// this is stored per document

	// Note the use of Hamamatsu's original coordinate system 
	// using y = -z
    if (index < 32)
	{
		d_angle = d_theta * index;
        angle = m_scanner_params.m_hda[0] - d_angle;
        dm = distance / cos(((12.243 - d_angle) * M_PI) / 180);
        xn = m_scanner_params.m_hdx[0] + dm * cos((angle * M_PI) / 180);
        yn = m_scanner_params.m_hdy[0] + dm * sin((angle * M_PI) / 180);
	}
    else if (index > 31 && index < 64) 
	{
		d_angle = d_theta * (index - 32);
        angle = m_scanner_params.m_hda[1] - d_theta * (index - 32);
        dm = distance / cos(((12.243 - d_angle) * M_PI) / 180);
        xn = m_scanner_params.m_hdx[1] + dm * cos((angle * M_PI) / 180);
        yn = m_scanner_params.m_hdy[1] + dm * sin((angle * M_PI) / 180);
	}
    else if (index > 63 && index < 96) 
	{
		d_angle = d_theta * (index - 64);
        angle = m_scanner_params.m_hda[2] - d_angle;
        dm = distance / cos(((12.243 - d_angle) * M_PI) / 180);
        xn = m_scanner_params.m_hdx[2] + dm * cos((angle * M_PI) / 180);
        yn = m_scanner_params.m_hdy[2] + dm * sin((angle * M_PI) / 180);
	}
    else if (index > 95 && index < 128)
	{
		d_angle = d_theta * (index - 96);
        angle = m_scanner_params.m_hda[3] - d_angle;
        dm = distance / cos(((12.243 - d_angle) * M_PI) / 180);
        xn = m_scanner_params.m_hdx[3] + dm * cos((angle * M_PI) / 180);
        yn = m_scanner_params.m_hdy[3] + dm * sin((angle * M_PI) / 180);
	}
    else if (index > 127 && index < 160)
	{
		d_angle = d_theta * (index - 128);
        angle = m_scanner_params.m_hda[4] + d_angle; //-11.9
        dm = distance / cos(((12.243 - d_angle) * M_PI) / 180);
        xn = m_scanner_params.m_hdx[4] - dm * cos((angle * M_PI) / 180);
        yn = m_scanner_params.m_hdy[4] + dm * sin((angle * M_PI) / 180);
	}
    else if (index > 159 && index < 192) 
	{
		d_angle = d_theta * (index - 160);
        angle = m_scanner_params.m_hda[5] + d_angle;
        dm = distance / cos(((12.243 - d_angle) * M_PI) / 180);
        xn = m_scanner_params.m_hdx[5] - dm * cos((angle * M_PI) / 180);
        yn = m_scanner_params.m_hdy[5] + dm * sin((angle * M_PI) / 180);
	}
    else if (index > 191 && index < 224) 
	{
		d_angle = d_theta * (index - 192);
        angle = m_scanner_params.m_hda[6] + d_angle;
        dm = distance / cos(((12.243 - d_angle) * M_PI) / 180);
        xn = m_scanner_params.m_hdx[6] - dm * cos((angle * M_PI) / 180);
        yn = m_scanner_params.m_hdy[6] + dm * sin((angle * M_PI) / 180);
	}
    else if (index > 223 && index < 256)
	{
		d_angle = d_theta * (index - 224);
        angle = m_scanner_params.m_hda[7] + d_angle;
        dm = distance / cos(((12.243 - d_angle) * M_PI) / 180);
        xn = m_scanner_params.m_hdx[7] - dm * cos((angle * M_PI) / 180);
        yn = m_scanner_params.m_hdy[7] + dm * sin((angle * M_PI) / 180);
    }

    // calculate the height of the current point, assuming
    // uniform movement of heads throughout scan

	double abs_index = slice*256+index;
	zn = 20000.0 - 20000.0 * (abs_index/102400.0);
	
	// correct the xyz values and output in the right-hand 
	// coordinate system 
	return SbVec3f(xn*m_x_correction,zn*m_y_correction,-yn*m_z_correction);
}

void CBodyAnalyserDoc::RenderBody()
{
	root = new SoSeparator;
	root->ref();

	// initialising drawstyles
	m_PointCloud_DrawStyle		= new SoDrawStyle;
	m_OutlierCloud_DrawStyle	= new SoDrawStyle;
	m_CoordOrigin_DrawStyle		= new SoDrawStyle;
	m_RefFrame_DrawStyle		= new SoDrawStyle;
	m_TextureEdgels_DrawStyle	= new SoDrawStyle;
	m_Connected_DrawStyle_0		= new SoDrawStyle;
	m_Connected_DrawStyle_1		= new SoDrawStyle;
	m_Connected_DrawStyle_2		= new SoDrawStyle;
	m_Connected_DrawStyle_3		= new SoDrawStyle;
	m_Connected_DrawStyle_4		= new SoDrawStyle;
	m_Connected_DrawStyle_5		= new SoDrawStyle;
	m_Connected_DrawStyle_6		= new SoDrawStyle;
	m_Connected_DrawStyle_7		= new SoDrawStyle;

	// initialising point cloud
	SoSeparator* s_pointCloud = new SoSeparator;
	s_pointCloud = RenderPointCloud();
	root->addChild(s_pointCloud);

	// initialising outlier cloud
	SoSeparator* s_outlierCloud = new SoSeparator;
	s_outlierCloud = RenderOutlierCloud();
	root->addChild(s_outlierCloud);

	// initialising reference frame
	SoSeparator* s_referenceFrame = new SoSeparator;
	s_referenceFrame = RenderReferenceFrame();
	root->addChild(s_referenceFrame);

	// initialising coordinate origin
	SoSeparator* s_coordOrigin = new SoSeparator;
	s_coordOrigin = RenderCoordOrigin();
	root->addChild(s_coordOrigin);

	// initialising connected mesh
	for(int i = 0; i < N_CAMERAS; i++)
	{	
		//connectedMesh[i] = new SoSeparator;
		//connectedMesh[i] = RenderConnectedMesh(i);
		//root->addChild(connectedMesh[i]);
	}
	
	// initialising triangulated mesh
	CalculateNormals();
	for(int j = 0; j < N_CAMERAS; j++)
	{
		s_triangMesh[j] = new SoSeparator;
		s_triangMesh[j] = RenderTriangMesh(j);
		root->addChild(s_triangMesh[j]);
	}


	IvfSetSceneGraph( root );
	root -> unref();

	//initialising toggles
	OnViewConnectedmeshAll();
	SetDisplayProperties(POINT_CLOUD);
	SetDisplayProperties(OUTLIER_CLOUD);
	m_colormapMode = TEXTURE;
	
}

// -----------------renderers -------------------------------------------------------------

SoSeparator* CBodyAnalyserDoc::RenderPointCloud()
{
	SoSeparator* S = new SoSeparator;			

	S->addChild(m_PointCloud_DrawStyle);

	int slice, index; 
	int i = 0;

	SoCoordinate3 *vertices = new SoCoordinate3;
		
	for(slice = 0; slice < N_SLICES; slice++)
	{
		for(index = 0; index < (N_LEDS*N_CAMERAS); index++)
		{
			if (m_flag_array[slice][index]!=REJECTED)
			{
			vertices->point.set1Value(i++, m_xyz_array[slice][index]);
			}
		}
	}


	SoPointSet *cPoints = new SoPointSet;
	S->addChild(vertices);

	SoMaterial  *pointColor = new SoMaterial;
	pointColor->diffuseColor.setValue(0.0, 0.0, 0.99); 
	S->addChild(pointColor);

	S->addChild(cPoints);

	return S;

}

SoSeparator* CBodyAnalyserDoc::RenderOutlierCloud()
{
	SoSeparator* S = new SoSeparator;			

	S->addChild(m_OutlierCloud_DrawStyle);

	int slice, index; 
	int i = 0;

	SoCoordinate3 *vertices = new SoCoordinate3;
		
	for(slice = 0; slice < N_SLICES; slice++)
	{
		for(index = 0; index < (N_LEDS*N_CAMERAS); index++)
		{
			if (m_flag_array[slice][index]==REJECTED)
			{
			vertices->point.set1Value(i++, m_xyz_array[slice][index]);
			}
		}
	}


	SoPointSet *cPoints = new SoPointSet;
	S->addChild(vertices);

	SoMaterial  *pointColor = new SoMaterial;
	pointColor->diffuseColor.setValue(0.8, 0.8, 0.8); 
	S->addChild(pointColor);

	S->addChild(cPoints);

	return S;

}


SoSeparator* CBodyAnalyserDoc::RenderReferenceFrame()
{
	SoSeparator* S = new SoSeparator;			int c,i;

	S->addChild(m_RefFrame_DrawStyle);

	SoMaterial *refFrameColor = new SoMaterial;
	refFrameColor->diffuseColor.setValue(0.35, 0.35, 0.5); 
	S->addChild(refFrameColor);

	float f = GLOBAL_SCALING_FACTOR;
	float small = -500*f;
	float large =  500*f;
	float  step = 50*f;
	float lim = 2000*f;


	//-----------------------------------------------------------RIGHT SIDE
	for(i = 0; i<=lim; i+=step)
	{
		SoSeparator* L = new SoSeparator;	c = 0;
	
		SoCoordinate3 *vertices = new SoCoordinate3;
		vertices->point.set1Value(c++, small, i, small);
		vertices->point.set1Value(c++, large, i, small);

		SoLineSet *cLines = new SoLineSet;
		L->addChild(vertices);
		L->addChild(cLines);

		S->addChild(L);
	}

	
	for(i = small; i<=large; i+=step)
	{
		SoSeparator* L = new SoSeparator;	c = 0;
	
		SoCoordinate3 *vertices = new SoCoordinate3;
		vertices->point.set1Value(c++, i, 0,   small);
		vertices->point.set1Value(c++, i, lim, small);

		SoLineSet *cLines = new SoLineSet;
		L->addChild(vertices);
		L->addChild(cLines);

		S->addChild(L);
	}

	//-----------------------------------------------------------REAR SIDE 
	
	for(i = 0; i<=lim; i+=step)
	{
		SoSeparator* L = new SoSeparator;	c = 0;
	
		SoCoordinate3 *vertices = new SoCoordinate3;
		vertices->point.set1Value(c++, large, i, small);
		vertices->point.set1Value(c++, large, i, large);

		SoLineSet *cLines = new SoLineSet;
		L->addChild(vertices);
		L->addChild(cLines);

		S->addChild(L);
	}
	
	for(i = small; i<=large; i+=step)
	{
		SoSeparator* L = new SoSeparator;	c = 0;
	
		SoCoordinate3 *vertices = new SoCoordinate3;
		vertices->point.set1Value(c++, large, 0,   i);
		vertices->point.set1Value(c++, large, lim, i);

		SoLineSet *cLines = new SoLineSet;
		L->addChild(vertices);
		L->addChild(cLines);
	
		S->addChild(L);
	}

	//-----------------------------------------------------------FLOOR 
	
	for(i = small; i<=large; i+=step)
	{
		SoSeparator* L = new SoSeparator;	c = 0;
	
		SoCoordinate3 *vertices = new SoCoordinate3;
		vertices->point.set1Value(c++, i, 0, small);
		vertices->point.set1Value(c++, i, 0, large);

		SoLineSet *cLines = new SoLineSet;
		L->addChild(vertices);
		L->addChild(cLines);

		S->addChild(L);
	}
	
	for(i = small; i<=large; i+=step)
	{
		SoSeparator* L = new SoSeparator;	c = 0;
	
		SoCoordinate3 *vertices = new SoCoordinate3;
		vertices->point.set1Value(c++, large, 0,   i);
		vertices->point.set1Value(c++, small, 0,   i);

		SoLineSet *cLines = new SoLineSet;
		L->addChild(vertices);
		L->addChild(cLines);
	
		S->addChild(L);
	}

	return S ;
}

SoSeparator* CBodyAnalyserDoc::RenderCoordOrigin()
{
	SoSeparator* S = new SoSeparator;	
	
	S->addChild(m_CoordOrigin_DrawStyle);

	SoMaterial *coordOriginColor = new SoMaterial;
	coordOriginColor->diffuseColor.setValue(1.0, 0.0, 0.0); 
	S->addChild(coordOriginColor);

	//x axis
	SoSeparator* aX = new SoSeparator;
	SoCoordinate3 *Xvertices = new SoCoordinate3;
	Xvertices->point.set1Value(0, 0, 0, 0);
	Xvertices->point.set1Value(1, 1500, 0, 0);
	SoLineSet *Xlines = new SoLineSet;
	aX->addChild(Xvertices);
	aX->addChild(Xlines);
	S->addChild(aX);
 
	//y axis
	SoSeparator* aY = new SoSeparator;
	SoCoordinate3 *Yvertices = new SoCoordinate3;
	Yvertices->point.set1Value(0, 0, 0, 0);
	Yvertices->point.set1Value(1, 0, 1000, 0);
	SoLineSet *Ylines = new SoLineSet;
	aY->addChild(Yvertices);
	aY->addChild(Ylines);
	S->addChild(aY);
 
	//z axis
	SoSeparator* aZ = new SoSeparator;
	SoCoordinate3 *Zvertices = new SoCoordinate3;
	Zvertices->point.set1Value(0, 0, 0, 0);
	Zvertices->point.set1Value(1, 0, 0, 500);
	SoLineSet *Zlines = new SoLineSet;
	aZ->addChild(Zvertices);
	aZ->addChild(Zlines);
	S->addChild(aZ);

	return S;
}

SoSeparator* CBodyAnalyserDoc::RenderTextureEdgels()
{
	SoSeparator* S = new SoSeparator;	

	SoSeparator* sph_sep;
	SoTranslation* sph_transl;
	SoSphere* sph;
	

	S->addChild(m_TextureEdgels_DrawStyle);
	m_TextureEdgels_DrawStyle->pointSize = 3;

	SoMaterial *texEdgelsColor = new SoMaterial;
	texEdgelsColor->diffuseColor.setValue(1.0, 0.0, 0.0); 
	S->addChild(texEdgelsColor);

	int slice, index; 
	int i = 0;

	SoCoordinate3 *vertices = new SoCoordinate3;
		
	for(slice = 0; slice < N_SLICES; slice++)
	{
		for(index = 0; index < (N_LEDS*N_CAMERAS); index++)
		{
			if ((m_edge_array[slice][index]) && (m_flag_array[slice][index]!=REJECTED))
			{
			vertices->point.set1Value(i++, m_xyz_array[slice][index]);
			/*
			sph_sep = new SoSeparator;

			sph = new SoSphere;
			sph->radius = 20;

			sph_transl = new SoTranslation;
			sph_transl->translation.setValue(m_xyz_array[slice][index]);

			S->addChild(sph_sep);
			sph_sep->addChild(sph_transl);
			sph_sep->addChild(sph);
			*/

			}
		}
	}


	SoPointSet *cPoints = new SoPointSet; //****************
	S->addChild(vertices);
	S->addChild(cPoints); //*******************
	return S;
}

SoSeparator* CBodyAnalyserDoc::RenderConnectedMesh(int cam)
{
	SoSeparator* S = new SoSeparator;	

	int start, finish;
	int index, slice;

	//replace this later
	switch (cam)
	{
	case 0: S->addChild(m_Connected_DrawStyle_0); break;
	case 1: S->addChild(m_Connected_DrawStyle_1); break;
	case 2: S->addChild(m_Connected_DrawStyle_2); break;
	case 3: S->addChild(m_Connected_DrawStyle_3); break;
	case 4: S->addChild(m_Connected_DrawStyle_4); break;
	case 5: S->addChild(m_Connected_DrawStyle_5); break;
	case 6: S->addChild(m_Connected_DrawStyle_6); break;
	case 7: S->addChild(m_Connected_DrawStyle_7); break;
	default: break;
	}

	start = camera_start[cam]+1;
	finish = camera_end[cam]-1;

	SoMaterial *coordOriginColor = new SoMaterial;
	coordOriginColor->diffuseColor.setValue(0.0, 0.0, 1.0); 
	S->addChild(coordOriginColor);

	//vertical
	for(index = start; index <= finish; index++)
	{
		for(slice = 0; slice<N_SLICES-1; slice++)
		{
			if( (m_flag_array[slice][index]!=REJECTED) && (m_flag_array[slice+1][index]!=REJECTED) )
			{
				SoSeparator* L = new SoSeparator;
				SoCoordinate3 *Lvertices = new SoCoordinate3;
				Lvertices->point.set1Value(0, m_xyz_array[slice][index]);
				Lvertices->point.set1Value(1, m_xyz_array[slice+1][index]);			
				SoLineSet *lines = new SoLineSet;
				L->addChild(Lvertices);
				L->addChild(lines);
				S->addChild(L);

			}
		}
	}

	//horizontal
	for(slice = 0; slice < N_SLICES; slice++)
	{
		for(index = start; index<finish; index++)
		{
			if( (m_flag_array[slice][index]!=REJECTED) && (m_flag_array[slice][index+1]!=REJECTED) )
			{
				SoSeparator* L = new SoSeparator;
				SoCoordinate3 *Lvertices = new SoCoordinate3;
				Lvertices->point.set1Value(0, m_xyz_array[slice][index]);
				Lvertices->point.set1Value(1, m_xyz_array[slice][index+1]);			
				SoLineSet *lines = new SoLineSet;
				L->addChild(Lvertices);
				L->addChild(lines);
				S->addChild(L);

			}
		}
	}


	return S;
}


SoSeparator* CBodyAnalyserDoc::RenderTriangMesh(int cam)
{
	SoSeparator* S = new SoSeparator;	

	int start, finish;
	int index, slice;

	int i;

	//replace this later
	switch (cam)
	{
	case 0: S->addChild(m_Connected_DrawStyle_0); break;
	case 1: S->addChild(m_Connected_DrawStyle_1); break;
	case 2: S->addChild(m_Connected_DrawStyle_2); break;
	case 3: S->addChild(m_Connected_DrawStyle_3); break;
	case 4: S->addChild(m_Connected_DrawStyle_4); break;
	case 5: S->addChild(m_Connected_DrawStyle_5); break;
	case 6: S->addChild(m_Connected_DrawStyle_6); break;
	case 7: S->addChild(m_Connected_DrawStyle_7); break;
	default: break;
	}

	start = camera_start[cam]+1;
	finish = camera_end[cam]-1;

	// Adding Vertices
	i = 0;
	SoCoordinate3* Tvertices = new SoCoordinate3;

	for(slice = 0; slice<N_SLICES; slice++)
	{
		for(index = start; index <= finish; index++)
		{
			if (m_indices[slice][index] != SO_END_FACE_INDEX)
			{
				Tvertices->point.set1Value(i, m_xyz_array[slice][index]);
				i++;
			}
		}
	}

	S->addChild(Tvertices);

	// Adding Normals
	i = 0;
	SoNormal* Tnormal = new SoNormal;

	for(slice = 0; slice<N_SLICES; slice++)
	{
		for(index = start; index <= finish; index++)
		{
			if (m_indices[slice][index] != SO_END_FACE_INDEX)
			{
				Tnormal->vector.set1Value(i, m_norm_array[slice][index]);
				i++;
			}
		}
	}

	S->addChild(Tnormal);

	// Adding Materials
	
	SoMaterial* Tmaterial = new SoMaterial;
	Tmaterial->ref();
	i = 0;

	for(slice = 0; slice<N_SLICES; slice++)
	{
		for(index = start; index <= finish; index++)
		{
			if (m_indices[slice][index] != SO_END_FACE_INDEX)
			{
				float c = (m_b_array[slice][index]) / 256.0;
				Tmaterial->diffuseColor.set1Value(i, c,c,c);
				i++;
			}
		}
	}

	m_Texture_Material[cam] = new SoMaterial;
	m_Texture_Material[cam]->ref();
	m_Texture_Material[cam] = Tmaterial; 
	//m_Texture_Material[cam]->transparency.setValue(0.1); 

	S->addChild(m_Texture_Material[cam]);


	m_Connected_Material_Binding[cam] = new SoMaterialBinding;
	m_Connected_Material_Binding[cam]->ref();
	m_Connected_Material_Binding[cam]->value = SoMaterialBinding::PER_VERTEX_INDEXED;
	S->addChild(m_Connected_Material_Binding[cam]);


	// Adding Indices
	i = 0;
	SoIndexedFaceSet* TfaceSet = new SoIndexedFaceSet;

	for(index = start; index < finish; index++)
	{
		for(slice = 0; slice<N_SLICES-1; slice++)
		{
			if (m_indices[slice][index] != SO_END_FACE_INDEX)
			{
				//downwards
				if (
					(m_indices[slice][index] != SO_END_FACE_INDEX) &&
					(m_indices[slice+1][index] != SO_END_FACE_INDEX) &&
					(m_indices[slice+1][index+1] != SO_END_FACE_INDEX)
					)
				{
					TfaceSet->coordIndex.set1Value(i++,m_indices[slice][index]);
					TfaceSet->coordIndex.set1Value(i++,m_indices[slice+1][index]);
					TfaceSet->coordIndex.set1Value(i++,m_indices[slice+1][index+1]);
					TfaceSet->coordIndex.set1Value(i++,SO_END_FACE_INDEX);
				}
				

				//to the right
				if (
					(m_indices[slice][index] != SO_END_FACE_INDEX) &&
					(m_indices[slice][index+1] != SO_END_FACE_INDEX) &&
					(m_indices[slice+1][index+1] != SO_END_FACE_INDEX)
					)
				{
					TfaceSet->coordIndex.set1Value(i++,m_indices[slice][index+1]);
					TfaceSet->coordIndex.set1Value(i++,m_indices[slice][index]);
					TfaceSet->coordIndex.set1Value(i++,m_indices[slice+1][index+1]);
					TfaceSet->coordIndex.set1Value(i++,SO_END_FACE_INDEX);
				}
				

			
			}
		}
	}

	S->addChild(TfaceSet);


	return S;

}

void CBodyAnalyserDoc::RenderCurvatureMap(int cam)
{
	// Adding Materials
	SoMaterial* Cmaterial = new SoMaterial;
	Cmaterial->ref();
	int i = 0;
	int slice,index;

	int start = camera_start[cam]+1;
	int finish = camera_end[cam]-1;

	//for(slice = 0; slice<N_SLICES; slice++)
	for(slice = 0; slice<N_SLICES; slice++)
	{
		for(index = start; index <= finish; index++)
		{
			if (m_indices[slice][index] != SO_END_FACE_INDEX)
			{
				float r = m_curv_map[slice][index]->r;
				float g = m_curv_map[slice][index]->g;
				float b = m_curv_map[slice][index]->b;
				Cmaterial->diffuseColor.set1Value(i, r,g,b);
				i++;
			}
		}
	}

	m_Curvature_Material[cam] = new SoMaterial;
	//m_Curvature_Material[cam]->ref();
	m_Curvature_Material[cam] = Cmaterial; 

}


// --------------------- responses to toggle view events -------------------------

void CBodyAnalyserDoc::SetDisplayProperties(int component)
{
	switch (component)
	{
	case POINT_CLOUD:
			if (m_showPointCloud==TRUE)		
			{m_PointCloud_DrawStyle->style.setValue(SoDrawStyle::POINTS);}
			else	
			{m_PointCloud_DrawStyle->style.setValue(SoDrawStyle::INVISIBLE);}
		break;
	case OUTLIER_CLOUD:
			if (m_showOutlierCloud==TRUE)		
			{m_OutlierCloud_DrawStyle->style.setValue(SoDrawStyle::POINTS);}
			else	
			{m_OutlierCloud_DrawStyle->style.setValue(SoDrawStyle::INVISIBLE);}
		break;
	case COORD_ORIGIN:
			if (m_showCoordOrigin==TRUE)	
			{m_CoordOrigin_DrawStyle->style.setValue(SoDrawStyle::LINES);}
			else	
			{m_CoordOrigin_DrawStyle->style.setValue(SoDrawStyle::INVISIBLE);}
		break;
	case REF_FRAME:
			if (m_showRefFrame==TRUE)		
			{m_RefFrame_DrawStyle->style.setValue(SoDrawStyle::LINES);}
			else	
			{m_RefFrame_DrawStyle->style.setValue(SoDrawStyle::INVISIBLE);}
		break;
	case TEXTURE_EDGELS:
			if (m_showTextureEdgels==TRUE)		
			{m_TextureEdgels_DrawStyle->style.setValue(SoDrawStyle::FILLED);}//filled!
			else	
			{m_TextureEdgels_DrawStyle->style.setValue(SoDrawStyle::INVISIBLE);}
		break;
	case CONNECTED_0:
			if (m_showConnected_0==TRUE)		
			{m_Connected_DrawStyle_0->style.setValue(SoDrawStyle::FILLED);}
			else	
			{m_Connected_DrawStyle_0->style.setValue(SoDrawStyle::INVISIBLE);}
		break;
	case CONNECTED_1:
			if (m_showConnected_1==TRUE)		
			{m_Connected_DrawStyle_1->style.setValue(SoDrawStyle::FILLED);}
			else	
			{m_Connected_DrawStyle_1->style.setValue(SoDrawStyle::INVISIBLE);}
		break;
	case CONNECTED_2:
			if (m_showConnected_2==TRUE)		
			{m_Connected_DrawStyle_2->style.setValue(SoDrawStyle::FILLED);}
			else	
			{m_Connected_DrawStyle_2->style.setValue(SoDrawStyle::INVISIBLE);}
		break;
	case CONNECTED_3:
			if (m_showConnected_3==TRUE)		
			{m_Connected_DrawStyle_3->style.setValue(SoDrawStyle::FILLED);}
			else	
			{m_Connected_DrawStyle_3->style.setValue(SoDrawStyle::INVISIBLE);}
		break;
	case CONNECTED_4:
			if (m_showConnected_4==TRUE)		
			{m_Connected_DrawStyle_4->style.setValue(SoDrawStyle::FILLED);}
			else	
			{m_Connected_DrawStyle_4->style.setValue(SoDrawStyle::INVISIBLE);}
		break;
	case CONNECTED_5:
			if (m_showConnected_5==TRUE)		
			{m_Connected_DrawStyle_5->style.setValue(SoDrawStyle::FILLED);}
			else	
			{m_Connected_DrawStyle_5->style.setValue(SoDrawStyle::INVISIBLE);}
		break;
	case CONNECTED_6:
			if (m_showConnected_6==TRUE)		
			{m_Connected_DrawStyle_6->style.setValue(SoDrawStyle::FILLED);}
			else	
			{m_Connected_DrawStyle_6->style.setValue(SoDrawStyle::INVISIBLE);}
		break;
	case CONNECTED_7:
			if (m_showConnected_7==TRUE)		
			{m_Connected_DrawStyle_7->style.setValue(SoDrawStyle::FILLED);}
			else	
			{m_Connected_DrawStyle_7->style.setValue(SoDrawStyle::INVISIBLE);}
		break;
	case CONNECTED_ALL:
			m_Connected_DrawStyle_0->style.setValue(SoDrawStyle::FILLED);
			m_Connected_DrawStyle_1->style.setValue(SoDrawStyle::FILLED);
			m_Connected_DrawStyle_2->style.setValue(SoDrawStyle::FILLED);
			m_Connected_DrawStyle_3->style.setValue(SoDrawStyle::FILLED);
			m_Connected_DrawStyle_4->style.setValue(SoDrawStyle::FILLED);
			m_Connected_DrawStyle_5->style.setValue(SoDrawStyle::FILLED);
			m_Connected_DrawStyle_6->style.setValue(SoDrawStyle::FILLED);
			m_Connected_DrawStyle_7->style.setValue(SoDrawStyle::FILLED);
		break;
	case CONNECTED_NONE:
			m_Connected_DrawStyle_0->style.setValue(SoDrawStyle::INVISIBLE);
			m_Connected_DrawStyle_1->style.setValue(SoDrawStyle::INVISIBLE);
			m_Connected_DrawStyle_2->style.setValue(SoDrawStyle::INVISIBLE);
			m_Connected_DrawStyle_3->style.setValue(SoDrawStyle::INVISIBLE);
			m_Connected_DrawStyle_4->style.setValue(SoDrawStyle::INVISIBLE);
			m_Connected_DrawStyle_5->style.setValue(SoDrawStyle::INVISIBLE);
			m_Connected_DrawStyle_6->style.setValue(SoDrawStyle::INVISIBLE);
			m_Connected_DrawStyle_7->style.setValue(SoDrawStyle::INVISIBLE);
		break;
	default:
		break;
	}//switch

}

// --------------------- responses to toggle view events -------------------------

void CBodyAnalyserDoc::OnViewPointcloud() 
{
	m_showPointCloud = (!m_showPointCloud);
	SetDisplayProperties(POINT_CLOUD);
}

void CBodyAnalyserDoc::OnViewOutliercloud() 
{
	m_showOutlierCloud = (!m_showOutlierCloud);
	SetDisplayProperties(OUTLIER_CLOUD);
}

void CBodyAnalyserDoc::OnViewCoordinateorigin() 
{
	m_showCoordOrigin = (!m_showCoordOrigin);
	SetDisplayProperties(COORD_ORIGIN);
}
void CBodyAnalyserDoc::OnViewReferenceframe() 

{
	m_showRefFrame = (!m_showRefFrame);
	SetDisplayProperties(REF_FRAME);
}

void CBodyAnalyserDoc::OnViewConnectedmeshCamera0() 
{
	m_showConnected_0 = (!m_showConnected_0);
	SetDisplayProperties(CONNECTED_0);
}

void CBodyAnalyserDoc::OnViewConnectedmeshCamera1() 
{
	m_showConnected_1 = (!m_showConnected_1);
	SetDisplayProperties(CONNECTED_1);
}

void CBodyAnalyserDoc::OnViewConnectedmeshCamera2() 
{
	m_showConnected_2 = (!m_showConnected_2);
	SetDisplayProperties(CONNECTED_2);
}

void CBodyAnalyserDoc::OnViewConnectedmeshCamera3() 
{
	m_showConnected_3 = (!m_showConnected_3);
	SetDisplayProperties(CONNECTED_3);
}

void CBodyAnalyserDoc::OnViewConnectedmeshCamera4() 
{
	m_showConnected_4 = (!m_showConnected_4);
	SetDisplayProperties(CONNECTED_4);
}

void CBodyAnalyserDoc::OnViewConnectedmeshCamera5() 
{
	m_showConnected_5 = (!m_showConnected_5);
	SetDisplayProperties(CONNECTED_5);
}

void CBodyAnalyserDoc::OnViewConnectedmeshCamera6() 
{
	m_showConnected_6 = (!m_showConnected_6);
	SetDisplayProperties(CONNECTED_6);
}

void CBodyAnalyserDoc::OnViewConnectedmeshCamera7() 
{
	m_showConnected_7 = (!m_showConnected_7);
	SetDisplayProperties(CONNECTED_7);
}

void CBodyAnalyserDoc::OnViewConnectedmeshAll() 
{
	m_showConnected_0 = TRUE;
	m_showConnected_1 = TRUE;
	m_showConnected_2 = TRUE;
	m_showConnected_3 = TRUE;
	m_showConnected_4 = TRUE;
	m_showConnected_5 = TRUE;
	m_showConnected_6 = TRUE;
	m_showConnected_7 = TRUE;
	SetDisplayProperties(CONNECTED_ALL);
}


void CBodyAnalyserDoc::OnViewConnectedmeshNone() 
{
	m_showConnected_0 = FALSE;
	m_showConnected_1 = FALSE;
	m_showConnected_2 = FALSE;
	m_showConnected_3 = FALSE;
	m_showConnected_4 = FALSE;
	m_showConnected_5 = FALSE;
	m_showConnected_6 = FALSE;
	m_showConnected_7 = FALSE;
	SetDisplayProperties(CONNECTED_NONE);
}

void CBodyAnalyserDoc::OnUseIntensities() 
{
	m_materialMode = (!m_materialMode);

	if(!m_materialMode)
	{	
		for(int j = 0; j < N_CAMERAS; j++)
		{
			m_Texture_Material[j]->diffuseColor.set1Value(0, 0.8,0.8,0.8);
			m_Connected_Material_Binding[j]->value = SoMaterialBinding::OVERALL;
		}
	}
	else
	{
		for(int j = 0; j < N_CAMERAS; j++)
		{
			m_Connected_Material_Binding[j]->value = SoMaterialBinding::PER_VERTEX_INDEXED;
		}
	}
}

// --------------------- menu updators --------------------------------------------

void CBodyAnalyserDoc::OnUpdateViewPointcloud(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_showPointCloud);
}

void CBodyAnalyserDoc::OnUpdateViewOutliercloud(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_showOutlierCloud);
}

void CBodyAnalyserDoc::OnUpdateViewCoordinateorigin(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_showCoordOrigin);
}

void CBodyAnalyserDoc::OnUpdateViewReferenceframe(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_showRefFrame);
}

void CBodyAnalyserDoc::OnUpdateViewConnectedmeshCamera0(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_showConnected_0);
}

void CBodyAnalyserDoc::OnUpdateViewConnectedmeshCamera1(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_showConnected_1);
}

void CBodyAnalyserDoc::OnUpdateViewConnectedmeshCamera2(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_showConnected_2);
}

void CBodyAnalyserDoc::OnUpdateViewConnectedmeshCamera3(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_showConnected_3);
}

void CBodyAnalyserDoc::OnUpdateViewConnectedmeshCamera4(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_showConnected_4);
}

void CBodyAnalyserDoc::OnUpdateViewConnectedmeshCamera5(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_showConnected_5);
}

void CBodyAnalyserDoc::OnUpdateViewConnectedmeshCamera6(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_showConnected_6);
}

void CBodyAnalyserDoc::OnUpdateViewConnectedmeshCamera7(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_showConnected_7);
}

void CBodyAnalyserDoc::OnUpdateViewConnectedmeshNone(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
}

void CBodyAnalyserDoc::OnUpdateViewConnectedmeshAll(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
}

void CBodyAnalyserDoc::OnUpdateUseIntensities(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_materialMode);
	pCmdUI->Enable(m_colormapMode==TEXTURE);
}

void CBodyAnalyserDoc::OnViewConnectedmeshCurvaturecolourmap() 
{
	int NDX;

	// TODO: Add your command handler code here
	if(!m_curv_map_calculated)
	{
		CNoCurvMapDialog cdlg;
		cdlg.DoModal();
	}
	else
	{
		if(m_colormapMode==CURVATURE)
		{
			m_colormapMode = TEXTURE;
			for(int j = 0; j < N_CAMERAS; j++)
			//for(int j = 1; j <= 1; j++)
			{
				s_triangMesh[j]->replaceChild(m_Curvature_Material[j],m_Texture_Material[j]);
			}
		}
		else
		{
			m_colormapMode = CURVATURE;
			for(int j = 0; j < N_CAMERAS; j++)
			//for(int j = 1; j <= 1; j++)
			{
				s_triangMesh[j]->replaceChild(m_Texture_Material[j],m_Curvature_Material[j]);
			}

		}

	}
}

void CBodyAnalyserDoc::OnUpdateViewConnectedmeshCurvaturecolourmap(CCmdUI* pCmdUI) 
{
	if(m_colormapMode==CURVATURE)
	{
		pCmdUI->SetText("Texture Colour Map");
	}
	else
	{
		pCmdUI->SetText("Curvature Colour Map");
	}
}


// ----------------------------------------------------------------------------------

void CBodyAnalyserDoc::CleanBody()
{
	Clean_Thresholding();
	Clean_FirstAndLast();
	Clean_SpatialCulling();
	Clean_ProximityTest();
	//Clean_BottomSlice();


}

void CBodyAnalyserDoc::Clean_Thresholding()
{
	int slice, index; 

	for(slice = 0; slice < N_SLICES; slice++)
	{
		for(index = 0; index < (N_CAMERAS*N_LEDS); index++)
		{
			if (m_b_array[slice][index]<=INTENSITY_THRESHOLD) 
				{m_flag_array[slice][index]=REJECTED;}
		}
	}

}

void CBodyAnalyserDoc::Clean_FirstAndLast()
{
	int slice, index; 

	for(slice = 0; slice < N_SLICES; slice++)
	{
		for(index = 0; index < (N_CAMERAS*N_LEDS); index++)
		{
			if (
				(index==camera_start[0]) || (index==camera_end[0]) ||
				(index==camera_start[1]) || (index==camera_end[1]) ||
				(index==camera_start[2]) || (index==camera_end[2]) ||
				(index==camera_start[3]) || (index==camera_end[3]) ||
				(index==camera_start[4]) || (index==camera_end[4]) ||
				(index==camera_start[5]) || (index==camera_end[5]) ||
				(index==camera_start[6]) || (index==camera_end[6]) ||
				(index==camera_start[7]) || (index==camera_end[7])
				) 
				{m_flag_array[slice][index]=REJECTED;}
		}
	}


}

void CBodyAnalyserDoc::Clean_SpatialCulling()
{
	int slice, index; 
	float x,y,z;

	int f = GLOBAL_SCALING_FACTOR;
	float lowlim = -490.0*f;
	float highlim = 490.0*f;

	for(slice = 0; slice < N_SLICES; slice++)
	{
		for(index = 0; index < (N_CAMERAS*N_LEDS); index++)
		{
			if (m_flag_array[slice][index] == ACCEPTED)
			{
				m_xyz_array[slice][index].getValue(x,y,z);

				if 
					(
						(x<lowlim) || (x>highlim) ||
	
						(z<lowlim) || (z>highlim) 
					)
					{m_flag_array[slice][index]=REJECTED;}
			}
		}
	}
}

void CBodyAnalyserDoc::Clean_ProximityTest()
{
	for(int slice = 0; slice < N_SLICES; slice++)	
	{
		Clean_Slice(slice);
		if(slice > (N_SLICES-3)) {Clean_BottomSlice(slice);}
	}
}

void CBodyAnalyserDoc::Clean_Slice(int s)
{
	float min_dist, temp_dist;
	float x1, y1, z1;
	float x2, y2, z2;

	for(int i = 0; i<(N_CAMERAS*N_LEDS); i++)
	{
		if(m_flag_array[s][i]!=REJECTED)
		{
			m_xyz_array[s][i].getValue(x1,y1,z1);
			min_dist=99999.9;
			for(int j = 0; j<(N_CAMERAS*N_LEDS); j++)
			{
				if( (i<j) && (m_flag_array[s][j]!=REJECTED) )
				{
					m_xyz_array[s][j].getValue(x2,y2,z2);
					temp_dist = eucDist(x1,y1,z1,x2,y2,z2);
					if(temp_dist<min_dist) {min_dist = temp_dist;}
				}
			}
			if(min_dist>DISTANCE_THRESHOLD) {m_flag_array[s][i]=REJECTED;}
		}
	}
}

void CBodyAnalyserDoc::Clean_BottomSlice(int s)
{
	float min_dist, temp_dist;
	float x1, y1, z1;
	float x2, y2, z2;

	for(int i = 0; i<(N_CAMERAS*N_LEDS); i++)
	{
		if(m_flag_array[s][i]!=REJECTED)
		{
			m_xyz_array[s][i].getValue(x1,y1,z1);
			min_dist=99999.9;
			for(int j = 0; j<(N_CAMERAS*N_LEDS); j++)
			{
				if(m_flag_array[s-1][j]!=REJECTED)
				{
					m_xyz_array[s-1][j].getValue(x2,y2,z2);
					temp_dist = eucDist(x1,y1,z1,x2,y2,z2);
					if(temp_dist<min_dist) {min_dist = temp_dist;}
				}
			}
			if(min_dist>DISTANCE_THRESHOLD) {m_flag_array[s][i]=REJECTED;}
		}
	}

}


//------CAMERA IMAGE GENERATION-------------------------------------------------------

void CBodyAnalyserDoc::CreateCameraImages()
{
	int slice, index, camera, gscale;; 

	int null_r = 120;
	int null_g = 150;
	int null_b = 220;

	float x,y,z;

	ofstream cam_img_file;

	cam_img_file.open("cam_imgs.hci");

	cam_img_file	<< N_CAMERAS << "\n" 
					<< N_LEDS << " " << N_SLICES << "\n" 
					<< N_GSCALES << " "<< N_CHANNELS << "\n";

	for(camera = 0; camera < N_CAMERAS; camera++)
	{
		for(slice = 0; slice < N_SLICES; slice++)
		{
			for(index = 0; index < N_LEDS; index++)  
			{
				if (m_flag_array[slice][index+(camera*N_LEDS)] == ACCEPTED)
				{ 
					m_xyz_array[slice][index+(camera*N_LEDS)].getValue(x,y,z);
					gscale = m_b_array[slice][index+(camera*N_LEDS)];
					cam_img_file << x << " " << y << " " << z << " " << gscale << "\n";
				}
				else
				{ 
					cam_img_file << 0 << " " << 0 << " " << 0 << " " << -1 << "\n"; 
				}
			}
		}
		
		cam_img_file << "\n";
	}

	cam_img_file.close();
}


//---------------- NORMALS -----------------------------------------------------------

void CBodyAnalyserDoc::CalculateNormals()
{
// also assigns an index number to every valid point that is
// associated to at least one triangle

	int slice,index;
	int start,finish;
	int camera;

	float x,y,z;	//current point
	float x1,y1,z1;
	float x2,y2,z2;
	float xn,yn,zn; //current normal
	float xs,ys,zs; //sum of normals
	
	int n_adjacent_faces;

	for(camera = 0; camera < N_CAMERAS; camera++)
	{
		start  = camera_start[camera];
		finish = camera_end[camera];

		valid_point_counter[camera] = 0;

		for(slice = 0; slice < N_SLICES; slice++)
		{
			for(index = start; index <= finish; index++)
			{
				if(m_flag_array[slice][index]!=REJECTED)
				{
					m_xyz_array[slice][index].getValue(x,y,z);
					
					n_adjacent_faces = xs = ys = zs = 0;
					
					//    2 3
					//   1   4
					//
					//   8   5
					//    7 6

					// 1
					if ( 
						( slice!=0 ) &&
						( index>start) &&
						( m_flag_array[slice-1][index-1]!=REJECTED ) &&
						( m_flag_array[slice][index-1]!=REJECTED ) 
						)
					{
						n_adjacent_faces++;

						m_xyz_array[slice-1][index-1].getValue(x1,y1,z1);
						m_xyz_array[slice][index-1].getValue(x2,y2,z2);

						CrossProduct(	x-x1,	y-y1,	z-z1,
										x1-x2,	y1-y2,	z1-z2,
										xn,		yn,		zn);

						xs += xn;
						ys += yn;
						zs += zn;
					}

					// 2
					if ( 
						( slice!=0 ) &&
						( index>start) &&
						( m_flag_array[slice-1][index]!=REJECTED ) &&
						( m_flag_array[slice-1][index-1]!=REJECTED ) 
						)
					{
						n_adjacent_faces++;

						m_xyz_array[slice-1][index].getValue(x1,y1,z1);
						m_xyz_array[slice-1][index-1].getValue(x2,y2,z2);

						CrossProduct(	x-x1,	y-y1,	z-z1,
										x1-x2,	y1-y2,	z1-z2,
										xn,		yn,		zn);

						xs += xn;
						ys += yn;
						zs += zn;
					}

					// 3
					if ( 
						( slice!=0 ) &&
						( index<finish) &&
						( m_flag_array[slice-1][index+1]!=REJECTED ) &&
						( m_flag_array[slice-1][index]!=REJECTED ) 
						)
					{
						n_adjacent_faces++;

						m_xyz_array[slice-1][index+1].getValue(x1,y1,z1);
						m_xyz_array[slice-1][index].getValue(x2,y2,z2);

						CrossProduct(	x-x1,	y-y1,	z-z1,
										x1-x2,	y1-y2,	z1-z2,
										xn,		yn,		zn);

						xs += xn;
						ys += yn;
						zs += zn;
					}

					// 4
					if ( 
						( slice!=0 ) &&
						( index<finish) &&
						( m_flag_array[slice][index+1]!=REJECTED ) &&
						( m_flag_array[slice-1][index+1]!=REJECTED ) 
						)
					{
						n_adjacent_faces++;

						m_xyz_array[slice][index+1].getValue(x1,y1,z1);
						m_xyz_array[slice-1][index+1].getValue(x2,y2,z2);

						CrossProduct(	x-x1,	y-y1,	z-z1,
										x1-x2,	y1-y2,	z1-z2,
										xn,		yn,		zn);

						xs += xn;
						ys += yn;
						zs += zn;
					}

					// 5
					if ( 
						( slice!=N_SLICES ) &&
						( index<finish) &&
						( m_flag_array[slice+1][index+1]!=REJECTED ) &&
						( m_flag_array[slice][index+1]!=REJECTED ) 
						)
					{
						n_adjacent_faces++;

						m_xyz_array[slice+1][index+1].getValue(x1,y1,z1);
						m_xyz_array[slice][index+1].getValue(x2,y2,z2);

						CrossProduct(	x-x1,	y-y1,	z-z1,
										x1-x2,	y1-y2,	z1-z2,
										xn,		yn,		zn);

						xs += xn;
						ys += yn;
						zs += zn;
					}

					// 6
					if ( 
						( slice!=N_SLICES ) &&
						( index<finish) &&
						( m_flag_array[slice+1][index]!=REJECTED ) &&
						( m_flag_array[slice+1][index+1]!=REJECTED ) 
						)
					{
						n_adjacent_faces++;

						m_xyz_array[slice+1][index].getValue(x1,y1,z1);
						m_xyz_array[slice+1][index+1].getValue(x2,y2,z2);

						CrossProduct(	x-x1,	y-y1,	z-z1,
										x1-x2,	y1-y2,	z1-z2,
										xn,		yn,		zn);

						xs += xn;
						ys += yn;
						zs += zn;
					}

					// 7
					if ( 
						( slice!=N_SLICES ) &&
						( index>start) &&
						( m_flag_array[slice+1][index-1]!=REJECTED ) &&
						( m_flag_array[slice+1][index]!=REJECTED ) 
						)
					{
						n_adjacent_faces++;

						m_xyz_array[slice+1][index-1].getValue(x1,y1,z1);
						m_xyz_array[slice+1][index].getValue(x2,y2,z2);

						CrossProduct(	x-x1,	y-y1,	z-z1,
										x1-x2,	y1-y2,	z1-z2,
										xn,		yn,		zn);

						xs += xn;
						ys += yn;
						zs += zn;
					}

					// 8
					if ( 
						( slice!=N_SLICES ) &&
						( index>start) &&
						( m_flag_array[slice+1][index-1]!=REJECTED ) &&
						( m_flag_array[slice+1][index]!=REJECTED ) 
						)
					{
						n_adjacent_faces++;

						m_xyz_array[slice][index-1].getValue(x1,y1,z1);
						m_xyz_array[slice+1][index-1].getValue(x2,y2,z2);

						CrossProduct(	x-x1,	y-y1,	z-z1,
										x1-x2,	y1-y2,	z1-z2,
										xn,		yn,		zn);

						xs += xn;
						ys += yn;
						zs += zn;
					}

					// associate index number if valid
					if (n_adjacent_faces > 0)
					{
						m_indices[slice][index] = valid_point_counter[camera];
						valid_point_counter[camera]++;
					}
					else
					{
						m_indices[slice][index] = SO_END_FACE_INDEX;
					}

					// average
					xs /= n_adjacent_faces;
					ys /= n_adjacent_faces;
					zs /= n_adjacent_faces;
				

					// normalise
					normaliseVector(xs,ys,zs);

					// assign vector value
					m_norm_array[slice][index].setValue(xs,ys,zs);

				}// end processing point
			}//end index
		}//end slice
	}//end camera
}

//-------------- AUXILIARY FUNCTIONS -------------------------------------------

float CBodyAnalyserDoc::eucDist(float x1, float y1, float z1, float x2, float y2, float z2)
{
	float dx = x1 - x2;
	float dy = y1 - y2;
	float dz = z1 - z2;
	float result = sqrt( (dx*dx) + (dy*dy) + (dz*dz) );
	return result;
}

void CBodyAnalyserDoc::normaliseVector(float& x, float& y, float& z)
{
	float m = vectorMagnitude(x,y,z);
	if (m>0)
	{
		x /= m;
		y /= m;
		z /= m;
	}
	else
	{
		x = y = z = 0.0;
	}
}

float CBodyAnalyserDoc::vectorMagnitude(float x, float y, float z)
{
	float m = eucDist(x,y,z,0.0,0.0,0.0);
	return m;
}




float CBodyAnalyserDoc::Gauss2D(float x, float y, float s)
{
	float xpr1 = ((x*x) + (y*y)) / (2*s*s);
	float xpr2 = exp(-xpr1);
	float xpr3 = 1.0/(2*PI*s*s);
	return xpr3*xpr2;
}

void CBodyAnalyserDoc::Convolve(SbVec3f data_in[MAX_N_SLICES+6][MAX_N_LEDS+6], float m[7][7], SbVec3f data_out[MAX_N_SLICES+6][MAX_N_LEDS+6], unsigned char flags[MAX_N_SLICES+6][MAX_N_LEDS+6])
{
	int i,j;
	float s;
	float x1,y1,z1,x2,y2,z2;

	for (int slice = 3; slice < N_SLICES+3; slice++)		
	{
		for (int index = 3; index < N_LEDS+3; index++)
		{
			if(flags[slice][index] != REJECTED)
			{

				float accX = 0.0;
				float accY = 0.0;
				float accZ = 0.0;
				float x,y,z;	
				
				s = 0.0;

				for(i = -3; i < 4; i++)
				{
					for(j = -3; j < 4; j++)
					{
						data_in[slice][index].getValue(x1,y1,z1);
						data_in[slice+i][index+j].getValue(x2,y2,z2);

						if(
							(flags[slice+i][index+j] != REJECTED) &&
							(eucDist(x1,y1,z1,x2,y2,z2) < DISTANCE_THRESHOLD)
							)
						{
							data_in[slice+i][index+j].getValue(x,y,z);
					
							float pX = m[i+3][j+3] * x;
							float pY = m[i+3][j+3] * y;
							float pZ = m[i+3][j+3] * z;

							accX += pX;
							accY += pY;
							accZ += pZ;

							s += m[i+3][j+3];
						}
					}
				}
	
				data_out[slice][index] = SbVec3f(accX/s,accY/s,accZ/s);
		
			}
		}
	}
}


// ------ PROCESSING TOOLS --------------------------------------


void CBodyAnalyserDoc::OnToolsCameraImager() 
{
	HINSTANCE CIV = ShellExecute(	
						NULL,
						"open", 
						camviewerpath,
						NULL,
						NULL,
						SW_SHOW);
}

void CBodyAnalyserDoc::OnToolsSurfacesmoothing() 
{
	int s,i,j;
	float x,y,z;

	CConfirmDialog cdlg;
	if (cdlg.DoModal() == IDOK)

for(int qwer = 0; qwer < 2; qwer++)
{

	{//SMOOTHING
				
		HCURSOR waitCursor = theApp.LoadStandardCursor(IDC_WAIT);
		SetCursor(waitCursor);

		// create temporary result arrays

		SbVec3f* m_r_array[MAX_N_SLICES];			// Cartesian coordinates
		for (s=0; s<N_SLICES; s++)		{m_r_array[s] = new SbVec3f[N_CAMERAS*N_LEDS];}

		// build gaussian convolution mask
		const int mask_size_factor = 1;
		const int mask_size = (mask_size_factor*6) + 1;
		float mask[mask_size][mask_size];
		float sigma = mask_size / 120.0;
		float start = -4.0 * sigma;
		float step = -(2.0*start)/(mask_size-1);
		for(i = 0; i < mask_size; i++)
		{
			for(j = 0; j < mask_size; j++)
			{
				mask[i][j] = Gauss2D(start+(i*step),start+(j*step),sigma);
			}
		}
				
		// render mask (temporary - remove later)
		//SoSeparator* gm = new SoSeparator;
		//gm = RenderGaussMask(mask);
		//root->addChild(gm);

		// convolve
		
		SbVec3f temp_in[MAX_N_SLICES+6][MAX_N_LEDS+6];
		SbVec3f temp_out[MAX_N_SLICES+6][MAX_N_LEDS+6];
		unsigned char flags_in[MAX_N_SLICES+6][MAX_N_LEDS+6];

		for(i = 0; i < MAX_N_SLICES+6; i++)
		{
			for(j = 0; j < MAX_N_LEDS+6; j++)
			{
				flags_in[i][j] = REJECTED;
				temp_in[i][j] = SbVec3f(0.0,0.0,0.0);
			}
		}
		
		int st,en;

		for(int cam = 0; cam < N_CAMERAS; cam++)
		{
			st = cam * N_LEDS;
			en = ((cam+1)*N_LEDS)-1;

			// copy sub-image to temporary array
			for(i = 3; i < N_SLICES+3; i++)
			{
				for(j = 3; j < N_LEDS+3; j++)
				{
					temp_in[i][j] = m_xyz_array[i-3][j-3+st];
					flags_in[i][j] = m_b_array[i-3][j-3+st];
				}
			}

			// call the convolution function
			Convolve(temp_in,mask,temp_out, flags_in);

			// copy resulting temporary array to result array
			for(i = 3; i < N_SLICES+3; i++)
			{
				for(j = 3; j < N_LEDS+3; j++)
				{
					m_r_array[i-3][j-3+st] = temp_out[i][j];
				}
			}

		}

		// copy result arrays to point arrays
		for (s=0; s<N_SLICES; s++)		
		{
			for (i=0; i<(N_CAMERAS*N_LEDS); i++)
			{
				m_xyz_array[s][i] = m_r_array[s][i];
			}
		}

		// delete result arrays
		for (s=0; s<N_SLICES; s++)		{delete m_r_array[s];}

		// re-render
		CalculateNormals();
		for(j = 0; j < N_CAMERAS; j++)
		{	
			smooth_triangMesh[j] = new SoSeparator;
			smooth_triangMesh[j] = RenderTriangMesh(j);
			root->replaceChild(s_triangMesh[j], smooth_triangMesh[j]);
			s_triangMesh[j] = smooth_triangMesh[j];
		}

		if (!m_materialMode)
		{
			OnUseIntensities();
			OnUseIntensities();
		}

		HCURSOR arrowCursor = theApp.LoadStandardCursor(IDC_ARROW);
		SetCursor(arrowCursor);

	}
}	
m_surface_smoothed = TRUE;
}

void CBodyAnalyserDoc::OnToolsCurvaturemap() 
{
//	CDlgCurvatureProgress DlgProgress;

  //magic numbers
	int detBthr = 0.4;



  CCurvMapConfirmDialog cdlg;
  if((!m_curv_map_calculated)&&(cdlg.DoModal()==IDOK))
  {
	HCURSOR waitCursor = theApp.LoadStandardCursor(IDC_WAIT);
	SetCursor(waitCursor);

	long double p_neigh[MAX_N_POINTS][3];// the array to store the point neighbourhood
	int neigh_size;
	CPointSet P;
	CQuadricSurf m_qs;
//	CPointMesh m_pm, m_cm;
//	CPointMesh* m_mesh = new CPointMesh;
//	CLandmarkMapping m_point_mapping;
	long double start_map[MAX_N][3];
	long double   end_map[MAX_N][3];
	long double RMS_biq, RMS_bic;

	long double temp_d;
	int c_i, c_j;
	long double c_x, c_y, c_z;
	long double detG, detB;	// the determinants of the fundamental forms
	long double gaussCurv;

	long double ms, mst; // the measure to be visualised, and its threshold.


	//derivative meshes:
//	CPointMesh* m_du;	// the first partial derivatives (for the 1st fund. frm)
//	CPointMesh* m_dv;	
//	CPointMesh* m_n	;	// the normals (for calculating rn)
//	CPointMesh* m_rn;	// the normals by surface 
//	CPointMesh* m_u	;	// the first partial derivatives of rn (for calculating the 2nd part ders)
//	CPointMesh* m_v	;	
//	CPointMesh* m_uu;	// the second partial derivatives of rn (for calculating the 2nd fund. form)
//	CPointMesh* m_uv;	
//	CPointMesh* m_vv;	

	//and some placeholders:
	long double rux, ruy, ruz;
	long double rvx, rvy, rvz;
	long double nx, ny, nz;
	long double ffm_E, ffm_F, ffm_G;
	long double sfm_L, sfm_M, sfm_N;


	int slice;				// the current slice (main loop)
	int index;				// the current index (main loop)
	float p_x,p_y,p_z;		// coords of the current point in the main loop
	float t_x,t_y,t_z;		// coords of the current point in the search loop
	int s,i,j;				// the current slice and index for the search loop
	int st_ndx,en_ndx;		// index limit for the current sensor
	int st_s,en_s;			// slice range for the search loop 
	int st_i,en_i;			// index range for the search loop
	float d;				// distance between current points in main and search loops
	int cam;				// current sensor

	int radius = 3;
	int radstep = 1;

	int kk = 9;
	int sk = 0;	


/*	
	for(slice = 0; slice < N_SLICES; slice++)
	{
		for(index = 0; index <= (N_CAMERAS*N_LEDS); index++)
		{
			if (m_indices[slice][index] != SO_END_FACE_INDEX)
			{
				m_curv_map[slice][index] = new CCurvatureProfile;
				m_curv_map[slice][index]->r = 0;
				m_curv_map[slice][index]->g = 0;
				m_curv_map[slice][index]->b = 0;
			}
		}
	}
*/


	// PHASE I - Calculation of the curvature tensor
	//for(slice = 0; slice < N_SLICES; slice++)

	//ofstream eigenfile;		eigenfile.open("eigenfile.txt");

	for(slice = 0; slice < N_SLICES; slice++)
	{
		st_s = slice - radius; if (st_s < 0) {st_s = 0;}
		en_s = slice + radius; if (en_s >=N_SLICES) {en_s = N_SLICES-1;}

		for(index = 0; index <= (N_CAMERAS*N_LEDS); index++)
		{
			st_ndx = cam*N_LEDS;
			en_ndx = ((cam+1)*N_LEDS)-1;
			st_i = index - radius; if (st_i < st_ndx) {st_i = st_ndx;}
			en_i = index + radius; if (en_i > en_ndx) {en_i = en_ndx;}

			cam = index / N_LEDS;

			if(m_flag_array[slice][index] != REJECTED  
				//&& (((slice+sk)%kk)==0) && ((index%(kk-2))==0) 
				&& (slice >= 145)
				&& (slice < 182)
				&& (index >= ((N_CAMERAS*N_LEDS*1)/8)+10)
				&& (index <= ((N_CAMERAS*N_LEDS*3)/8)-21)
				)
			{
				m_curv_map[slice][index] = new CCurvatureProfile;
				m_xyz_array[slice][index].getValue(p_x,p_y,p_z);

				//select a number of points around m_xyz_array[slice][index]
				//(try DISTANCE_THRESHOLD)
				neigh_size = 0;

				for(s = st_s; s <= en_s; s+=radstep)
				{
					for(i = st_i; i <= en_i; i+=radstep)
					{
						if((m_flag_array[s][i] != REJECTED)&&(neigh_size<(MAX_N_POINTS-3)) )
						{
							m_xyz_array[s][i].getValue(t_x,t_y,t_z);
							d = eucDist(p_x,p_y,p_z,t_x,t_y,t_z);
							if (d < (0.7*DISTANCE_THRESHOLD))
							{
								p_neigh[neigh_size][0] = t_x;
								p_neigh[neigh_size][1] = t_y;
								p_neigh[neigh_size][2] = t_z;
								neigh_size++;
							}	//endif
						}	// endif - 
					}	//end looping by index
				}	// end looping by slice
				if(neigh_size >= 10) 
				{
					// quadric fitting
					P = CPointSet(neigh_size,&p_neigh);
					m_qs = QuadricSurfFit(&P);

					//dumping the eigenvalues (debugging purposes only)
					//eigenfile << m_qs.l1 << "\t" << m_qs.l2 << "\n";

					//closest point calculation
					CFloatMatrix* x0 = new CFloatMatrix(4,1);
					CFloatMatrix* xx = new CFloatMatrix();
					//copying the point
					x0->set(0,0,p_x);	
					x0->set(1,0,p_y);
					x0->set(2,0,p_z);
					x0->set(3,0,1.0);

					//calculation of the closest point
					long double sss[MAX_N_POINTS][3];				// sss is a debug-only argument
					xx = QuadricClosestPoint(m_qs, x0/*, sss*/);		// must be removed when code is finished

					// retrieval of the resulting point
					long double m_x[MAX_N_POINTS][3];
					m_x[0][0] = xx->get(0,0);
					m_x[0][1] = xx->get(1,0);
					m_x[0][2] = xx->get(2,0);

					// rendering the result
					//CPointSet Px = CPointSet(1,&m_x);		Px.SetPointSize(7);		Px.SetColour(0.8,0,1); /*lilac*/	root->addChild(Px.render());

					// calculation of curvatures
					m_qs.Curvatures(m_x[0][0]-m_qs.centre[0],
					m_x[0][1]-m_qs.centre[1],
					m_x[0][2]-m_qs.centre[2]);

					delete x0;
					delete xx;
				}


				// render the patches (optional - for debugging purposes only)
				/*
				if (	(neigh_size>=10) && 
						(
							
						//		(slice > 150) && 
						//		(slice < 210) &&  
						//		(index > 32) && 
						//		(index < 84) && 
								(((slice+sk)%kk)==0) && 
								((index%(kk-2))==0)
							
						)
					)
				{
					PP = PointCloudFromQuadric(m_qs);
					root->addChild(PP.render());
				} 
				*/


				// chromatic association
				
				// --- temporary
				if(neigh_size<10)
				{
						m_curv_map[slice][index]->r = 1;
						m_curv_map[slice][index]->g = 1;
						m_curv_map[slice][index]->b = 1;
				}
				else
				{	
					long double hh = m_qs.H*100.0; 
					if (hh>255.0) {hh=255.0;}
					m_curv_map[slice][index]->r = (255-hh)/255;
					m_curv_map[slice][index]->g = 1;
					m_curv_map[slice][index]->b = (255-hh)/255;

					/*
					if(m_qs.K<0.0)
					{
						m_curv_map[slice][index]->r = 1;
						m_curv_map[slice][index]->g = 1;
						m_curv_map[slice][index]->b = 0;
					}
					else
					{
						m_curv_map[slice][index]->r = 0;
						m_curv_map[slice][index]->g = 1;
						m_curv_map[slice][index]->b = 1;
					}
					*/
				}



				// --- the proper way to do it, when curvature has been calculated
				/*
				ms = gaussCurv;
				mst = detBthr;

				if(neigh_size<6)
				{
						m_curv_map[slice][index]->r = 1;
						m_curv_map[slice][index]->g = 1;
						m_curv_map[slice][index]->b = 0;
				}
				else
				{	
					if(ms < (-mst))
					{
						m_curv_map[slice][index]->r = 0;
						m_curv_map[slice][index]->g = 1;
						m_curv_map[slice][index]->b = 0;
					}
					if( (ms >= (-mst)) && (ms <= 0) )
					{
						m_curv_map[slice][index]->r = 0;
						m_curv_map[slice][index]->g = (-ms)/mst;
						m_curv_map[slice][index]->b = 0;
					}
					if( (ms <= mst) && (ms > 0) )
					{
						m_curv_map[slice][index]->r = ms/mst;
						m_curv_map[slice][index]->g = 0;
						m_curv_map[slice][index]->b = 0;
					}
					if(ms > mst)
					{
						m_curv_map[slice][index]->r = 1;
						m_curv_map[slice][index]->g = 0;
						m_curv_map[slice][index]->b = 0;

					}
				}
				*/

			}	//endif
			else
			{
				m_curv_map[slice][index] = new CCurvatureProfile;
				m_curv_map[slice][index]->r = 0;
				m_curv_map[slice][index]->g = 0;
				m_curv_map[slice][index]->b = 0;
			}  //endelse

		}	//end looping by index

		//DlgProgress.DoModal();	

	}	//end looping by slice

//	eigenfile.close();


	// PHASE II - visualisation
	for(cam = 0; cam < N_CAMERAS; cam++)	{RenderCurvatureMap(cam);}

	// PHASE III (Later) - Extraction of features
	m_curv_map_calculated = TRUE;

	HCURSOR arrowCursor = theApp.LoadStandardCursor(IDC_ARROW);
	SetCursor(arrowCursor);

	// Display the damn thing!!!
	//if(!m_materialMode) {OnUseIntensities();}
	OnViewConnectedmeshCurvaturecolourmap();

  }// end if(!m_curv_map_calculated)	

}
///------------------ Curvature Mapping Components ----------------------------------------




///////////////////////////////////////////////////////////////////////////////////////////
///  TEMPORARY FUNCTIONS - REMOVE WHEN DONE


SoSeparator* CBodyAnalyserDoc::RenderGaussMask(float m[7][7])
{
	SoSeparator* S = new SoSeparator;			

	//S->addChild(m_PointCloud_DrawStyle);

	int i,j,c;

	float x,y,z;
	float f = 1000.0;

	SoCoordinate3 *vertices = new SoCoordinate3;
	
	c = 0;
	for(i = 0; i < 7; i++)
	{
		for(j = 0; j < 7; j++)
		{
			x = f*(float)i;
			y = f*(float)j;
			z = f*m[i][j];
			vertices->point.set1Value(c++, x, y, z);
		}
	}


	SoPointSet *cPoints = new SoPointSet;
	S->addChild(vertices);

	SoMaterial  *pointColor = new SoMaterial;
	pointColor->diffuseColor.setValue(0.0, 1.0, 0.3); 
	S->addChild(pointColor);

	S->addChild(cPoints);

	return S;

}



void CBodyAnalyserDoc::OnToolsTextureedgedetector() 
{

	float curr_image[MAX_IMAGE_X][MAX_IMAGE_Y];
	BOOL curr_edges[MAX_IMAGE_X][MAX_IMAGE_Y];
	
	CCannyParamsDialog m_cpd;
	m_cpd.m_masksize = c_gmask;
	m_cpd.m_upper_threshold = c_uhthr;
	m_cpd.m_lower_threshold = c_lhthr;

	if(m_cpd.DoModal()==IDOK)
	{
		c_gmask = m_cpd.m_masksize;
		c_uhthr = m_cpd.m_upper_threshold;
		c_lhthr = m_cpd.m_lower_threshold;

	
		HCURSOR waitCursor = theApp.LoadStandardCursor(IDC_WAIT);
		SetCursor(waitCursor);

		int led;

		for(int i = 0; i < N_CAMERAS; i++)
		{
			//copy out the current image
			int st_ndx = i * N_LEDS;
			int en_ndx = ((i+1)*N_LEDS)-1;

			for(led = 0; led < N_LEDS; led++)
			{
				for(int slice = 0; slice < N_SLICES; slice++)
				{
					curr_image[led][slice] = (float)m_b_array[slice][led+st_ndx];
				}
			}

			//call the canny function
			CannyEdgeDetector(&curr_image, &curr_edges, N_LEDS, N_SLICES, c_gmask, c_lhthr, c_uhthr);

			//copy results back
			for(led = 0; led < N_LEDS; led++)
			{
				for(int slice = 0; slice < N_SLICES; slice++)
				{
					m_edge_array[slice][led+st_ndx] = curr_edges[led][slice];

					//remove this when done
					m_b_array[slice][led+st_ndx] = (unsigned char)curr_image[led][slice];
				}
			}

			//remove this when done
			//SoSeparator* newTex = new SoSeparator;
			//newTex = RenderTriangMesh(i);
			//root -> replaceChild(s_triangMesh[i],newTex);
			//s_triangMesh[i] = newTex;
		}

		//rendering the results
		if(m_texture_edges_detected)	
		{	
			SoSeparator* newEdgels = new SoSeparator;
			newEdgels = RenderTextureEdgels();
			root->replaceChild(s_textureEdgels,newEdgels);
			s_textureEdgels = newEdgels;
		}
		else
		{
			s_textureEdgels = new SoSeparator;
			s_textureEdgels = RenderTextureEdgels();
			root->addChild(s_textureEdgels);
		}

		//setting display properties
		m_showTextureEdgels = TRUE;
		m_texture_edges_detected = TRUE;	

		HCURSOR arrowCursor = theApp.LoadStandardCursor(IDC_ARROW);
		SetCursor(arrowCursor);
	}

}

void CBodyAnalyserDoc::OnUpdateToolsTextureedgedetector(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	
}

void CBodyAnalyserDoc::OnUpdateViewConnectedmeshTextureedgels(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(m_texture_edges_detected);
	pCmdUI->SetCheck(m_showTextureEdgels);
}

void CBodyAnalyserDoc::OnViewConnectedmeshTextureedgels() 
{
	m_showTextureEdgels = (!m_showTextureEdgels);
	SetDisplayProperties(TEXTURE_EDGELS);
}


void CBodyAnalyserDoc::OnToolsHistogramequalisation() 
{

	HCURSOR waitCursor = theApp.LoadStandardCursor(IDC_WAIT);
	SetCursor(waitCursor);

	int slice,index;
	float max = -999.0;
	float min = 9999.0;
	float val,newval;

	for(slice = 0; slice < N_SLICES; slice++)
	{
		for(index = 0; index < N_CAMERAS*N_LEDS; index++)
		{
			val = (float)m_b_array[slice][index];
			if(val>max) {max = val;}
			if(val<min) {min = val;}
		}
	}

	for(slice = 0; slice < N_SLICES; slice++)
	{
		for(index = 0; index < N_CAMERAS*N_LEDS; index++)
		{
			val = (float)m_b_array[slice][index];
			newval = (val/max)*255.0;
			m_b_array[slice][index] = (unsigned char)newval;
		}
	}

	//re-rendering
	for(int i = 0; i < N_CAMERAS; i++)
	{
		SoSeparator* newTex = new SoSeparator;
		newTex = RenderTriangMesh(i);
		root -> replaceChild(s_triangMesh[i],newTex);
		s_triangMesh[i] = newTex;
	}

	HCURSOR arrowCursor = theApp.LoadStandardCursor(IDC_ARROW);
	SetCursor(arrowCursor);
}

void CBodyAnalyserDoc::OnUpdateToolsCurvaturemap(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	//pCmdUI->Enable(m_surface_smoothed);
	
}

//----------------------------------------- NEW CURVATURE MAPPING FUNCTIONS

void CBodyAnalyserDoc::OnToolsCurvaturemapExportcovariances() 
{
  if(!m_curv_map_calculated)
  {
	HCURSOR waitCursor = theApp.LoadStandardCursor(IDC_WAIT);
	SetCursor(waitCursor);

	
	char* sm_filename = "d:\\Documents\\Temp\\test_input.txt";
	ofstream sm_file;
	sm_file.open(sm_filename,ios::out|ios::trunc);
	sm_file << N_SLICES << " " << N_CAMERAS << " " << N_LEDS << "\n\n";


	long double p_neigh[MAX_N_POINTS][3];// the array to store the point neighbourhood
	int neigh_size;
	CPointSet P;
	//CQuadricSurf m_qs;


	int slice;				// the current slice (main loop)
	int index;				// the current index (main loop)
	float p_x,p_y,p_z;		// coords of the current point in the main loop
	float t_x,t_y,t_z;		// coords of the current point in the search loop
	int s,i,j;				// the current slice and index for the search loop
	int st_ndx,en_ndx;		// index limit for the current sensor
	int st_s,en_s;			// slice range for the search loop 
	int st_i,en_i;			// index range for the search loop
	float d;				// distance between current points in main and search loops
	int cam;				// current sensor

	int radius = 3;
	int radstep = 1;

	int kk = 9;
	int sk = 0;	

	int n;
	const int N = 10;
	long double x,y,z;
	int ii,jj;

	unsigned int slice_offset = 160;							unsigned int slice_range = N_LEDS;
	unsigned int index_offset = N_LEDS;							unsigned int index_range = N_LEDS;

	// PHASE I - Calculation of the curvature tensor
	//for(slice = 0; slice < N_SLICES; slice++)

	//ofstream eigenfile;		eigenfile.open("eigenfile.txt");

	for(slice = 0; slice < N_SLICES; slice++)
	{
		st_s = slice - radius; if (st_s < 0) {st_s = 0;}
		en_s = slice + radius; if (en_s >=N_SLICES) {en_s = N_SLICES-1;}

		for(index = 0; index <= (N_CAMERAS*N_LEDS); index++)
		{
			st_ndx = cam*N_LEDS;
			en_ndx = ((cam+1)*N_LEDS)-1;
			st_i = index - radius; if (st_i < st_ndx) {st_i = st_ndx;}
			en_i = index + radius; if (en_i > en_ndx) {en_i = en_ndx;}

			cam = index / N_LEDS;

			if( (m_flag_array[slice][index] != REJECTED)  
				//&& (((slice+sk)%kk)==0) && ((index%(kk-2))==0) 
				&& (slice >= slice_offset)
				&& (slice < slice_offset + slice_range)
				&& (index >= index_offset)
				&& (index <= index_offset + index_range)
				)
			{
				//m_curv_map[slice][index] = new CCurvatureProfile;/*obsolete*/
				m_xyz_array[slice][index].getValue(p_x,p_y,p_z);

				//select a number of points around m_xyz_array[slice][index]
				//(try DISTANCE_THRESHOLD)
				neigh_size = 0;

				for(s = st_s; s <= en_s; s+=radstep)
				{
					for(i = st_i; i <= en_i; i+=radstep)
					{
						//if((m_flag_array[s][i] != REJECTED)&&(neigh_size<(MAX_N_POINTS-3)) )
						if((m_flag_array[s][i] != REJECTED)&&(neigh_size<(26)) ) //(limitation due to matrix size)
						{
							m_xyz_array[s][i].getValue(t_x,t_y,t_z);
							d = eucDist(p_x,p_y,p_z,t_x,t_y,t_z);
							if (d < (0.7*DISTANCE_THRESHOLD))
							{
								p_neigh[neigh_size][0] = t_x;
								p_neigh[neigh_size][1] = t_y;
								p_neigh[neigh_size][2] = t_z;
								neigh_size++;
							}	//endif
						}	// endif - 
					}	//end looping by index
				}	// end looping by slice
				if(neigh_size >= 10) 
				{//calculate and export the covariance matrix


					//generate the point set
					P = CPointSet(neigh_size,&p_neigh);
					n = neigh_size;
					CFloatMatrix* D = new CFloatMatrix(n,N);
					P.Center();
					
					
					//building the design matrix
					for(ii=0; ii<n; ii++)
					{
						x = P.a[ii][0];
						y = P.a[ii][1];
						z = P.a[ii][2];

						D->set(ii,0,x*x);		
						D->set(ii,1,y*y);		
						D->set(ii,2,z*z);		
						D->set(ii,3,x*y);		
						D->set(ii,4,y*z);		
						D->set(ii,5,x*z);		
						D->set(ii,6,x);		
						D->set(ii,7,y);		
						D->set(ii,8,z);		
						D->set(ii,9,1.0);		
					}
					CFloatMatrix* DT = new CFloatMatrix(N,n);
					DT = Transp(D);

					//building the scatter matrix
					CFloatMatrix* S = new CFloatMatrix;
					S = Multiply(DT,D);

					//export
					sm_file << "1 \n";
					for(ii=0; ii<10; ii++)
					{
						for(jj=0; jj<10; jj++)
						{
							sm_file << S->get(ii,jj) << " ";
						}sm_file << "\n";
					} 

					//exporting 
					for(ii=0; ii<3; ii++)
					{
						sm_file << P.mean[ii] << " ";
					} sm_file << "\n";


					//garbage collection
					delete D;
					delete DT;
					delete S;

				}
				else
				{
					//write down a dummy to the file
					sm_file << "0 \n";

				}
			} // if not rejected
			else
			{
				//write down a dummy to the file
				sm_file << "0 \n";
			}
		}//loop by index
	}//loop by slice
	sm_file.close();
	HCURSOR arrowCursor = theApp.LoadStandardCursor(IDC_ARROW);
	SetCursor(arrowCursor);

  }//if not done
}

void CBodyAnalyserDoc::OnToolsCurvaturemapRetrieveeigensolutions() 
{
	HCURSOR waitCursor = theApp.LoadStandardCursor(IDC_WAIT);
	SetCursor(waitCursor);

	char* sm_filename = "d:\\Documents\\Temp\\test_output.txt";
	ifstream sm_file;
	sm_file.open(sm_filename,ios::in|ios::nocreate);
	//setbuf(sm_file,NULL);
	
	unsigned int sm_flag;
	unsigned int n_sl, n_cm, n_ld;
	sm_file >> n_sl;
	sm_file >> n_cm;
	sm_file >> n_ld;
	ASSERT(n_sl == N_SLICES);
	ASSERT(n_cm == N_CAMERAS);
	ASSERT(n_ld == N_LEDS);

	const int N = 10;
	const int N2 = 100;

	unsigned int i,j;
	unsigned int k;
	float p_x, p_y, p_z;
	CQuadricSurf m_qs;
	float s_val;

	//intermediate matrices
	float L[N];
	float V[N][N];
	float mu[N];
	float mean[3];
	float sss[MAX_N_POINTS][3];				// sss is a debug-only argument
	long double quadric_coeffs[10];
	float m_x[MAX_N_POINTS][3];

	unsigned int slice, index;


	for(slice = 0; slice < N_SLICES; slice++)
	{
		for(index = 0; index <= (N_CAMERAS*N_LEDS); index++)
		{
			//allocate memory
			m_curv_map[slice][index] = new CCurvatureProfile;

			//load the flag
			sm_file >> sm_flag;
			if (sm_flag == 1)
			{
	CFloatMatrix*  u = new CFloatMatrix(N,1);
	CFloatMatrix* uT = new CFloatMatrix(1,N);
	CFloatMatrix* temp1 = new CFloatMatrix(N,1);
	CFloatMatrix* temp2 = new CFloatMatrix(1,1);
	CFloatMatrix* S = new CFloatMatrix(N,N);
	CFloatMatrix* x0 = new CFloatMatrix(4,1);
	CFloatMatrix* xx = new CFloatMatrix();

				//load the results
				
				//eigenvalues (L)
				for(j=0; j<N; j++)	{sm_file >> L[j];}
				fflush(NULL);

				//eigenvectors (V)
				for(j=0; j<N; j++)	
				{
					for(i=0; i<N; i++)	
					{
						sm_file >> V[i][j];
					}
				}
				fflush(NULL);

				//mean
				for(j=0; j<3; j++)	{sm_file >> mean[j];}
				fflush(NULL);

				//design matrix (s)
				for(j=0; j<N; j++)	
				{
					for(i=0; i<N; i++)	
					{
						sm_file >> s_val;
						S->set(i,j,s_val);
					}
				}
				fflush(NULL);
 
				//retrieve the point
				m_xyz_array[slice][index].getValue(p_x,p_y,p_z);

				//naughty!!!
				for(j=0; j<N; j++)
				{
					if ( (L[j]) < 0.0 ) 
					{L[j] = 999999.9;}
				}


				//get the lowest eigenvector
				k = 0;
				for(j=1; j<N; j++)
				{
					if ( fabs(L[j]) < fabs(L[j-1]) ) 
					{k=j;}
				}





				ASSERT(L[k]>=0.0);
				mu[k] = 10; //does this do anything useful at all???

	
				for(j=0; j<N; j++)
				{
					for(i=0; i<N; i++)
					{
						u->set(i,0,V[i][j]);
					}

					uT = Transp(u);

					temp1 = Multiply(S,u);
					temp2 = Multiply(uT,temp1);

					mu[j] = sqrt(1.0/ (temp2->get(0,0)) );
				}


				//push the diagonal elements back into the surface object m_qs
				quadric_coeffs[0] = mu[k]*V[0][k];
				quadric_coeffs[1] = mu[k]*V[1][k];
				quadric_coeffs[2] = mu[k]*V[2][k];
				quadric_coeffs[3] = mu[k]*V[3][k];
				quadric_coeffs[4] = mu[k]*V[4][k];
				quadric_coeffs[5] = mu[k]*V[5][k];
				quadric_coeffs[6] = mu[k]*V[6][k];
				quadric_coeffs[7] = mu[k]*V[7][k];
				quadric_coeffs[8] = mu[k]*V[8][k];
				quadric_coeffs[9] = mu[k]*V[9][k];
			
				m_qs = CQuadricSurf(quadric_coeffs);
				m_qs.l1 = L[0];
				m_qs.l2 = L[1];

				for(i = 0; i < 3; i++)			{m_qs.centre[i] = mean[i];}


				//closest point calculation
			
				//copying the point
				x0->set(0,0,p_x);	
				x0->set(1,0,p_y);
				x0->set(2,0,p_z);
				x0->set(3,0,1.0);

				//calculation of the closest point
				xx = QuadricClosestPoint(m_qs, x0/*, sss*/);		// must be removed when code is finished

				// retrieval of the resulting point
				m_x[0][0] = xx->get(0,0);
				m_x[0][1] = xx->get(1,0);
				m_x[0][2] = xx->get(2,0);

				// calculation of curvatures
				m_qs.Curvatures(m_x[0][0]-m_qs.centre[0],
				m_x[0][1]-m_qs.centre[1],
				m_x[0][2]-m_qs.centre[2]);

	//garbage collection
	delete u;
	delete uT;
	delete temp1;
	delete temp2;
	delete S;
	delete x0;
	delete xx;

		
				//chromatic assosiaction (of a successful patch) - gaussian curvature
				if(m_qs.K>0)
				{
					m_curv_map[slice][index]->r = 0;
					m_curv_map[slice][index]->g = 0;
					m_curv_map[slice][index]->b = 1;
				}
				else
				{
					m_curv_map[slice][index]->r = 1;
					m_curv_map[slice][index]->g = 0;
					m_curv_map[slice][index]->b = 0;
				}

				//chromatic assosiaction (of a successful patch) - mean curvature
/*				if(fabs(m_qs.H)>0.6)
				{
					m_curv_map[slice][index]->r = 1;
					m_curv_map[slice][index]->g = 0;
					m_curv_map[slice][index]->b = 0;
				}
				else
				{
					m_curv_map[slice][index]->r = 1;
					m_curv_map[slice][index]->g = 1;
					m_curv_map[slice][index]->b = 1;
				}
*/

			}
			else
			{
				//chromatic association of an unsuccessful patch)
				m_curv_map[slice][index]->r = 0;
				m_curv_map[slice][index]->g = 0;
				m_curv_map[slice][index]->b = 0;
			}
		}//loop by index
	}//loop by slice



	//visualisation and closing
	sm_file.close();
	for(int cam = 0; cam < N_CAMERAS; cam++) {RenderCurvatureMap(cam);}
	m_curv_map_calculated = TRUE;
	HCURSOR arrowCursor = theApp.LoadStandardCursor(IDC_ARROW);
	SetCursor(arrowCursor);
	OnViewConnectedmeshCurvaturecolourmap();

}
